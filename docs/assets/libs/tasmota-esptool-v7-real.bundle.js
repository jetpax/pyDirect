var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32.json
var require_esp32 = __commonJS({
  "temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32.json"(exports, module) {
    module.exports = {
      entry: 1074521712,
      text: "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",
      text_start: 1074520064,
      data: "DMD8P3HoC0AH6QtAke0LQKfpC0Aq6QtAp+kLQADqC0AH6wtAfesLQCLrC0Ad6AtAs+oLQPzqC0Ae6gtAnusLQEjqC0Ce6wtA/ugLQGDpC0Cn6QtAAOoLQBDpC0Bs7AtAVu0LQIjtC0By7QtAiO0LQIjtC0CI7QtAiO0LQIjtC0CI7QtAiO0LQIjtC0D/6wtAiO0LQIfsC0BW7QtA",
      data_start: 1073605548,
      bss_start: 1073528832
    };
  }
});

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32s2.json
var require_esp32s2 = __commonJS({
  "temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32s2.json"(exports, module) {
    module.exports = {
      entry: 1073907892,
      text: "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",
      text_start: 1073905664,
      data: "WAD9P/KLAkCHjAJAK5ECQCeNAkCqjAJAJ40CQICNAkCDjgJA+Y4CQJ6OAkB9iwJAL44CQHiOAkCejQJAGo8CQMaNAkAajwJAfowCQOCMAkAnjQJAgI0CQJCMAkC+iwJA9I8CQOKQAkAikQJABpECQCKRAkAikQJAIpECQCKRAkAikQJAIpECQCKRAkAikQJAe48CQCKRAkAQkAJA4pACQA==",
      data_start: 1073622016,
      bss_start: 1073545216
    };
  }
});

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32s3.json
var require_esp32s3 = __commonJS({
  "temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32s3.json"(exports, module) {
    module.exports = {
      entry: 1077382356,
      text: "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",
      text_start: 1077379072,
      data: "WADKP6qQN0B/kTdAGZY3QB+SN0CikTdAH5I3QHiSN0B/kzdA9ZM3QJqTN0A1kDdAJ5M3QHSTN0CWkjdAFpQ3QL6SN0AWlDdAdpE3QNiRN0AfkjdAeJI3QIiRN0B2kDdA8JQ3QN6VN0AQljdA+pU3QBCWN0AQljdAEJY3QBCWN0AQljdAEJY3QBCWN0AQljdAd5Q3QBCWN0AMlTdA3pU3QAQInwAAAAAAAAAYAQQIBQAAAAAAAAAIAQQIBgAAAAAAAAAAAQQIIQAAAAAAIAAAEQQI3AAAAAAAIAAAEQQIDAAAAAAAIAAAAQQIEgAAAAAAIAAAESAoDAAQAQAA",
      data_start: 1070279676,
      bss_start: 1070202880
    };
  }
});

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp8266.json
var require_esp8266 = __commonJS({
  "temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp8266.json"(exports, module) {
    module.exports = {
      entry: 1074843652,
      text: "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",
      text_start: 1074843648,
      data: "CIH+PwUFBAACAwcAAwMLAOzXEEAj2BBAUdgQQO7YEECd5xBAUtkQQKjZEED02RBAnecQQLraEEA32xBA+NsQQJ3nEECd5xBAkNwQQJ3nEEBt3xBANOAQQG/gEECd5xBAnecQQAvhEECd5xBA8+EQQJniEEDY4xBAl+QQQGjlEECd5xBAnecQQJ3nEECd5xBAluYQQJ3nEECM5xBAyN0QQMHYEEDa5RBA4doQQDPaEECd5xBAIOcQQGfnEECd5xBAnecQQJ3nEECd5xBAnecQQJ3nEECd5xBAnecQQFraEECX2hBA8uUQQAEAAAACAAAAAwAAAAQAAAAFAAAABwAAAAkAAAANAAAAEQAAABkAAAAhAAAAMQAAAEEAAABhAAAAgQAAAMEAAAABAQAAgQEAAAECAAABAwAAAQQAAAEGAAABCAAAAQwAAAEQAAABGAAAASAAAAEwAAABQAAAAWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAUAAAAGAAAABgAAAAcAAAAHAAAACAAAAAgAAAAJAAAACQAAAAoAAAAKAAAACwAAAAsAAAAMAAAADAAAAA0AAAANAAAAAAAAAAAAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAANAAAADwAAABEAAAATAAAAFwAAABsAAAAfAAAAIwAAACsAAAAzAAAAOwAAAEMAAABTAAAAYwAAAHMAAACDAAAAowAAAMMAAADjAAAAAgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAgAAAAMAAAADAAAAAwAAAAMAAAAEAAAABAAAAAQAAAAEAAAABQAAAAUAAAAFAAAABQAAAAAAAAAAAAAAAAAAABAREgAIBwkGCgULBAwDDQIOAQ8AAQEAAAEAAAAEAAAA",
      data_start: 1073720492,
      bss_start: 1073643776
    };
  }
});

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32c2.json
var require_esp32c2 = __commonJS({
  "temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32c2.json"(exports, module) {
    module.exports = {
      entry: 1077413350,
      text: "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",
      text_start: 1077411840,
      data: "DEDKP+IIOEBICThA3Ak4QLAKOEAYCzhAxgo4QNAHOEBsCjhArAo4QPgJOECABzhAIAo4QIAHOEDACDhACAk4QEgJOEDcCThA0gg4QP4HOEAyCDhAzgg4QAoNOEBICThA1As4QM4MOEBcBzhA8Aw4QFwHOEBcBzhAXAc4QFwHOEBcBzhAXAc4QFwHOEBcBzhAegs4QFwHOEDsCzhAzgw4QA==",
      data_start: 1070295980,
      bss_start: 1070219264
    };
  }
});

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32c3.json
var require_esp32c3 = __commonJS({
  "temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32c3.json"(exports, module) {
    module.exports = {
      entry: 1077413654,
      text: "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",
      text_start: 1077411840,
      data: "FEDIP9oKOEBECzhA1gs4QKoMOEASDThAwAw4QLQJOEBmDDhApgw4QPILOEBkCThAGgw4QGQJOEC4CjhAAgs4QEQLOEDWCzhAygo4QNwJOEAoCjhAxgo4QAwPOEBECzhAzg04QMgOOEAiCThA7g44QCIJOEAiCThAIgk4QCIJOEAiCThAIgk4QCIJOEAiCThAdA04QCIJOEDmDThAyA44QA==",
      data_start: 1070164916,
      bss_start: 1070088192
    };
  }
});

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32c5.json
var require_esp32c5 = __commonJS({
  "temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32c5.json"(exports, module) {
    module.exports = {
      entry: 1082133196,
      text: "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",
      text_start: 1082130432,
      data: "FACEQDAPgECaD4BALhCAQAIRgEBqEYBAGBGAQIoNgEC+EIBA/hCAQEoQgEA6DYBAchCAQDoNgEAMD4BAWA+AQJoPgEAuEIBAHg+AQLINgEDgDYBAGg+AQGQTgECaD4BAJhKAQCATgED0DIBARhOAQPQMgED0DIBA9AyAQPQMgED0DIBA9AyAQPQMgED0DIBAzBGAQPQMgEA+EoBAIBOAQA==",
      data_start: 1082469300,
      bss_start: 1082392576
    };
  }
});

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32c6.json
var require_esp32c6 = __commonJS({
  "temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32c6.json"(exports, module) {
    module.exports = {
      entry: 1082132230,
      text: "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",
      text_start: 1082130432,
      data: "EACEQIYKgEDwCoBAfguAQFIMgEC6DIBAaAyAQHgJgEAODIBATgyAQJoLgEAoCYBAwguAQCgJgEBkCoBArgqAQPAKgEB+C4BAdgqAQKAJgEDUCYBAcgqAQLQOgEDwCoBAdg2AQHAOgEDmCIBAlg6AQOYIgEDmCIBA5giAQOYIgEDmCIBA5giAQOYIgEDmCIBAHA2AQOYIgECODYBAcA6AQA==",
      data_start: 1082469296,
      bss_start: 1082392576
    };
  }
});

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32c61.json
var require_esp32c61 = __commonJS({
  "temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32c61.json"(exports, module) {
    module.exports = {
      entry: 1082132230,
      text: "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",
      text_start: 1082130432,
      data: "EECAQIoKgED0CoBAgguAQFYMgEC+DIBAbAyAQHwJgEASDIBAUgyAQJ4LgEAsCYBAxguAQCwJgEBoCoBAsgqAQPQKgECCC4BAegqAQKQJgEDYCYBAdgqAQLgOgED0CoBAeg2AQHQOgEDqCIBAmg6AQOoIgEDqCIBA6giAQOoIgEDqCIBA6giAQOoIgEDqCIBAIA2AQOoIgECSDYBAdA6AQA==",
      data_start: 1082223536,
      bss_start: 1082146816
    };
  }
});

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32h2.json
var require_esp32h2 = __commonJS({
  "temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32h2.json"(exports, module) {
    module.exports = {
      entry: 1082132230,
      text: "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",
      text_start: 1082130432,
      data: "EACDQIYKgEDwCoBAfguAQFIMgEC6DIBAaAyAQHgJgEAODIBATgyAQJoLgEAoCYBAwguAQCgJgEBkCoBArgqAQPAKgEB+C4BAdgqAQKAJgEDUCYBAcgqAQLQOgEDwCoBAdg2AQHAOgEDmCIBAlg6AQOYIgEDmCIBA5giAQOYIgEDmCIBA5giAQOYIgEDmCIBAHA2AQOYIgECODYBAcA6AQA==",
      data_start: 1082403760,
      bss_start: 1082327040
    };
  }
});

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32p4r3.json
var require_esp32p4r3 = __commonJS({
  "temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32p4r3.json"(exports, module) {
    module.exports = {
      entry: 1341459424,
      text: "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",
      text_start: 1341456384,
      data: "XAD2T/gQ9U9iEfVP/hH1T9oS9U9CE/VP8BL1T04P9U+WEvVP1hL1TxoS9U/+DvVPQhL1T/4O9U/UEPVPIBH1T2IR9U/+EfVP5hD1T3gP9U+uD/VP4hD1TzwV9U9iEfVPBhT1TwAV9U8gDvVPIhX1TyAO9U8gDvVPIA71TyAO9U8gDvVPIA71TyAO9U8gDvVPpBP1TyAO9U8eFPVPABX1Tw==",
      data_start: 1341598716,
      bss_start: 1341521920
    };
  }
});

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32p4.json
var require_esp32p4 = __commonJS({
  "temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/esp32p4.json"(exports, module) {
    module.exports = {
      entry: 1341197280,
      text: "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",
      text_start: 1341194240,
      data: "XAD1T/gQ8U9iEfFP/hHxT9oS8U9CE/FP8BLxT04P8U+WEvFP1hLxTxoS8U/+DvFPQhLxT/4O8U/UEPFPIBHxT2IR8U/+EfFP5hDxT3gP8U+uD/FP4hDxTzwV8U9iEfFPBhTxTwAV8U8gDvFPIhXxTyAO8U8gDvFPIA7xTyAO8U8gDvFPIA7xTyAO8U8gDvFPpBPxTyAO8U8eFPFPABXxTw==",
      data_start: 1341533180,
      bss_start: 1341456384
    };
  }
});

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/util.js
var slipEncode = (buffer) => {
  let encoded = [192];
  for (const byte of buffer) {
    if (byte == 219) {
      encoded = encoded.concat([219, 221]);
    } else if (byte == 192) {
      encoded = encoded.concat([219, 220]);
    } else {
      encoded.push(byte);
    }
  }
  encoded.push(192);
  return encoded;
};
var toByteArray = (str) => {
  const byteArray = [];
  for (let i = 0; i < str.length; i++) {
    const charcode = str.charCodeAt(i);
    if (charcode <= 255) {
      byteArray.push(charcode);
    }
  }
  return byteArray;
};
var hexFormatter = (bytes) => "[" + bytes.map((value) => toHex(value)).join(", ") + "]";
var toHex = (value, size = 2) => {
  const hex = value.toString(16).toUpperCase();
  if (hex.startsWith("-")) {
    return "-0x" + hex.substring(1).padStart(size, "0");
  } else {
    return "0x" + hex.padStart(size, "0");
  }
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/const.js
var DETECTED_FLASH_SIZES = {
  18: "256KB",
  19: "512KB",
  20: "1MB",
  21: "2MB",
  22: "4MB",
  23: "8MB",
  24: "16MB",
  25: "32MB",
  26: "64MB",
  27: "128MB",
  28: "256MB",
  32: "64MB",
  33: "128MB",
  34: "256MB",
  50: "256KB",
  51: "512KB",
  52: "1MB",
  53: "2MB",
  54: "4MB",
  55: "8MB",
  56: "16MB",
  57: "32MB",
  58: "64MB"
};
var FLASH_WRITE_SIZE = 1024;
var STUB_FLASH_WRITE_SIZE = 16384;
var FLASH_SECTOR_SIZE = 4096;
var ESP_ROM_BAUD = 115200;
var USB_JTAG_SERIAL_PID = 4097;
var ESP8266_SPI_REG_BASE = 1610613248;
var ESP8266_BASEFUSEADDR = 1072693328;
var ESP8266_MACFUSEADDR = 1072693328;
var ESP8266_SPI_USR_OFFS = 28;
var ESP8266_SPI_USR1_OFFS = 32;
var ESP8266_SPI_USR2_OFFS = 36;
var ESP8266_SPI_MOSI_DLEN_OFFS = -1;
var ESP8266_SPI_MISO_DLEN_OFFS = -1;
var ESP8266_SPI_W0_OFFS = 64;
var ESP8266_UART_DATE_REG_ADDR = 1610612856;
var ESP8266_BOOTLOADER_FLASH_OFFSET = 0;
var ESP32_SPI_REG_BASE = 1072963584;
var ESP32_BASEFUSEADDR = 1073061888;
var ESP32_MACFUSEADDR = 1073061888;
var ESP32_SPI_USR_OFFS = 28;
var ESP32_SPI_USR1_OFFS = 32;
var ESP32_SPI_USR2_OFFS = 36;
var ESP32_SPI_MOSI_DLEN_OFFS = 40;
var ESP32_SPI_MISO_DLEN_OFFS = 44;
var ESP32_SPI_W0_OFFS = 128;
var ESP32_UART_DATE_REG_ADDR = 1610612856;
var ESP32_BOOTLOADER_FLASH_OFFSET = 4096;
var ESP32S2_SPI_REG_BASE = 1061167104;
var ESP32S2_BASEFUSEADDR = 1061265408;
var ESP32S2_MACFUSEADDR = 1061265476;
var ESP32S2_SPI_USR_OFFS = 24;
var ESP32S2_SPI_USR1_OFFS = 28;
var ESP32S2_SPI_USR2_OFFS = 32;
var ESP32S2_SPI_MOSI_DLEN_OFFS = 36;
var ESP32S2_SPI_MISO_DLEN_OFFS = 40;
var ESP32S2_SPI_W0_OFFS = 88;
var ESP32S2_UART_DATE_REG_ADDR = 1610612856;
var ESP32S2_BOOTLOADER_FLASH_OFFSET = 4096;
var ESP32S3_SPI_REG_BASE = 1610620928;
var ESP32S3_BASEFUSEADDR = 1610641408;
var ESP32S3_MACFUSEADDR = 1610641408 + 68;
var ESP32S3_SPI_USR_OFFS = 24;
var ESP32S3_SPI_USR1_OFFS = 28;
var ESP32S3_SPI_USR2_OFFS = 32;
var ESP32S3_SPI_MOSI_DLEN_OFFS = 36;
var ESP32S3_SPI_MISO_DLEN_OFFS = 40;
var ESP32S3_SPI_W0_OFFS = 88;
var ESP32S3_UART_DATE_REG_ADDR = 1610612864;
var ESP32S3_BOOTLOADER_FLASH_OFFSET = 0;
var ESP32C2_SPI_REG_BASE = 1610620928;
var ESP32C2_BASEFUSEADDR = 1610647552;
var ESP32C2_MACFUSEADDR = 1610647552 + 68;
var ESP32C2_SPI_USR_OFFS = 24;
var ESP32C2_SPI_USR1_OFFS = 28;
var ESP32C2_SPI_USR2_OFFS = 32;
var ESP32C2_SPI_MOSI_DLEN_OFFS = 36;
var ESP32C2_SPI_MISO_DLEN_OFFS = 40;
var ESP32C2_SPI_W0_OFFS = 88;
var ESP32C2_UART_DATE_REG_ADDR = 1610612860;
var ESP32C2_BOOTLOADER_FLASH_OFFSET = 0;
var ESP32C3_SPI_REG_BASE = 1610620928;
var ESP32C3_BASEFUSEADDR = 1610647552;
var ESP32C3_MACFUSEADDR = 1610647552 + 68;
var ESP32C3_SPI_USR_OFFS = 24;
var ESP32C3_SPI_USR1_OFFS = 28;
var ESP32C3_SPI_USR2_OFFS = 32;
var ESP32C3_SPI_MOSI_DLEN_OFFS = 36;
var ESP32C3_SPI_MISO_DLEN_OFFS = 40;
var ESP32C3_SPI_W0_OFFS = 88;
var ESP32C3_UART_DATE_REG_ADDR = 1610612860;
var ESP32C3_BOOTLOADER_FLASH_OFFSET = 0;
var ESP32C5_SPI_REG_BASE = 1610625024;
var ESP32C5_BASEFUSEADDR = 1611352064;
var ESP32C5_MACFUSEADDR = 1611352064 + 68;
var ESP32C5_SPI_USR_OFFS = 24;
var ESP32C5_SPI_USR1_OFFS = 28;
var ESP32C5_SPI_USR2_OFFS = 32;
var ESP32C5_SPI_MOSI_DLEN_OFFS = 36;
var ESP32C5_SPI_MISO_DLEN_OFFS = 40;
var ESP32C5_SPI_W0_OFFS = 88;
var ESP32C5_UART_DATE_REG_ADDR = 1610612860;
var ESP32C5_BOOTLOADER_FLASH_OFFSET = 8192;
var ESP32C6_SPI_REG_BASE = 1610625024;
var ESP32C6_BASEFUSEADDR = 1611335680;
var ESP32C6_MACFUSEADDR = 1611335680 + 68;
var ESP32C6_SPI_USR_OFFS = 24;
var ESP32C6_SPI_USR1_OFFS = 28;
var ESP32C6_SPI_USR2_OFFS = 32;
var ESP32C6_SPI_MOSI_DLEN_OFFS = 36;
var ESP32C6_SPI_MISO_DLEN_OFFS = 40;
var ESP32C6_SPI_W0_OFFS = 88;
var ESP32C6_UART_DATE_REG_ADDR = 1610612860;
var ESP32C6_BOOTLOADER_FLASH_OFFSET = 0;
var ESP32C61_SPI_REG_BASE = 1610625024;
var ESP32C61_BASEFUSEADDR = 1611352064;
var ESP32C61_MACFUSEADDR = 1611352064 + 68;
var ESP32C61_SPI_USR_OFFS = 24;
var ESP32C61_SPI_USR1_OFFS = 28;
var ESP32C61_SPI_USR2_OFFS = 32;
var ESP32C61_SPI_MOSI_DLEN_OFFS = 36;
var ESP32C61_SPI_MISO_DLEN_OFFS = 40;
var ESP32C61_SPI_W0_OFFS = 88;
var ESP32C61_UART_DATE_REG_ADDR = 1610612860;
var ESP32C61_BOOTLOADER_FLASH_OFFSET = 0;
var ESP32H2_SPI_REG_BASE = 1610625024;
var ESP32H2_BASEFUSEADDR = 1611335680;
var ESP32H2_MACFUSEADDR = 1611335680 + 68;
var ESP32H2_SPI_USR_OFFS = 24;
var ESP32H2_SPI_USR1_OFFS = 28;
var ESP32H2_SPI_USR2_OFFS = 32;
var ESP32H2_SPI_MOSI_DLEN_OFFS = 36;
var ESP32H2_SPI_MISO_DLEN_OFFS = 40;
var ESP32H2_SPI_W0_OFFS = 88;
var ESP32H2_UART_DATE_REG_ADDR = 1610612860;
var ESP32H2_BOOTLOADER_FLASH_OFFSET = 0;
var ESP32H4_SPI_REG_BASE = 1611239424;
var ESP32H4_BASEFUSEADDR = 1611339776;
var ESP32H4_MACFUSEADDR = 1611339776 + 68;
var ESP32H4_SPI_USR_OFFS = 24;
var ESP32H4_SPI_USR1_OFFS = 28;
var ESP32H4_SPI_USR2_OFFS = 32;
var ESP32H4_SPI_MOSI_DLEN_OFFS = 36;
var ESP32H4_SPI_MISO_DLEN_OFFS = 40;
var ESP32H4_SPI_W0_OFFS = 88;
var ESP32H4_UART_DATE_REG_ADDR = 1610686464 + 124;
var ESP32H4_BOOTLOADER_FLASH_OFFSET = 8192;
var ESP32H21_SPI_REG_BASE = 1610625024;
var ESP32H21_BASEFUSEADDR = 1611350016;
var ESP32H21_MACFUSEADDR = 1611350016 + 68;
var ESP32H21_SPI_USR_OFFS = 24;
var ESP32H21_SPI_USR1_OFFS = 28;
var ESP32H21_SPI_USR2_OFFS = 32;
var ESP32H21_SPI_MOSI_DLEN_OFFS = 36;
var ESP32H21_SPI_MISO_DLEN_OFFS = 40;
var ESP32H21_SPI_W0_OFFS = 88;
var ESP32H21_UART_DATE_REG_ADDR = 1610612860;
var ESP32H21_BOOTLOADER_FLASH_OFFSET = 0;
var ESP32P4_SPI_REG_BASE = 1342754816;
var ESP32P4_BASEFUSEADDR = 1343410176;
var ESP32P4_EFUSE_BLOCK1_ADDR = ESP32P4_BASEFUSEADDR + 68;
var ESP32P4_MACFUSEADDR = 1343410176 + 68;
var ESP32P4_SPI_USR_OFFS = 24;
var ESP32P4_SPI_USR1_OFFS = 28;
var ESP32P4_SPI_USR2_OFFS = 32;
var ESP32P4_SPI_MOSI_DLEN_OFFS = 36;
var ESP32P4_SPI_MISO_DLEN_OFFS = 40;
var ESP32P4_SPI_W0_OFFS = 88;
var ESP32P4_UART_DATE_REG_ADDR = 1343004672 + 140;
var ESP32P4_BOOTLOADER_FLASH_OFFSET = 8192;
var ESP32S31_SPI_REG_BASE = 542113792;
var ESP32S31_BASEFUSEADDR = 544296960;
var ESP32S31_EFUSE_BLOCK1_ADDR = ESP32S31_BASEFUSEADDR + 68;
var ESP32S31_MACFUSEADDR = 544296960 + 68;
var ESP32S31_SPI_USR_OFFS = 24;
var ESP32S31_SPI_USR1_OFFS = 28;
var ESP32S31_SPI_USR2_OFFS = 32;
var ESP32S31_SPI_MOSI_DLEN_OFFS = 36;
var ESP32S31_SPI_MISO_DLEN_OFFS = 40;
var ESP32S31_SPI_W0_OFFS = 88;
var ESP32S31_UART_DATE_REG_ADDR = 540581888 + 140;
var ESP32S31_BOOTLOADER_FLASH_OFFSET = 8192;
var SYNC_PACKET = toByteArray("\x07\x07 UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU");
var CHIP_DETECT_MAGIC_REG_ADDR = 1073745920;
var CHIP_FAMILY_ESP8266 = 33382;
var CHIP_FAMILY_ESP32 = 50;
var CHIP_FAMILY_ESP32S2 = 12882;
var CHIP_FAMILY_ESP32S3 = 12883;
var CHIP_FAMILY_ESP32C2 = 12994;
var CHIP_FAMILY_ESP32C3 = 12995;
var CHIP_FAMILY_ESP32C5 = 12997;
var CHIP_FAMILY_ESP32C6 = 12998;
var CHIP_FAMILY_ESP32C61 = 207969;
var CHIP_FAMILY_ESP32H2 = 12914;
var CHIP_FAMILY_ESP32H4 = 12916;
var CHIP_FAMILY_ESP32H21 = 12917;
var CHIP_FAMILY_ESP32P4 = 12928;
var CHIP_FAMILY_ESP32S31 = 12849;
var CHIP_ID_TO_INFO = {
  5: { name: "ESP32-C3", family: CHIP_FAMILY_ESP32C3 },
  9: { name: "ESP32-S3", family: CHIP_FAMILY_ESP32S3 },
  12: { name: "ESP32-C2", family: CHIP_FAMILY_ESP32C2 },
  13: { name: "ESP32-C6", family: CHIP_FAMILY_ESP32C6 },
  16: { name: "ESP32-H2", family: CHIP_FAMILY_ESP32H2 },
  18: { name: "ESP32-P4", family: CHIP_FAMILY_ESP32P4 },
  20: { name: "ESP32-C61", family: CHIP_FAMILY_ESP32C61 },
  23: { name: "ESP32-C5", family: CHIP_FAMILY_ESP32C5 },
  25: { name: "ESP32-H21", family: CHIP_FAMILY_ESP32H21 },
  28: { name: "ESP32-H4", family: CHIP_FAMILY_ESP32H4 },
  32: { name: "ESP32-S31", family: CHIP_FAMILY_ESP32S31 }
};
var CHIP_DETECT_MAGIC_VALUES = {
  4293968129: { name: "ESP8266", family: CHIP_FAMILY_ESP8266 },
  15736195: { name: "ESP32", family: CHIP_FAMILY_ESP32 },
  1990: { name: "ESP32-S2", family: CHIP_FAMILY_ESP32S2 }
};
var ESP_FLASH_BEGIN = 2;
var ESP_FLASH_DATA = 3;
var ESP_FLASH_END = 4;
var ESP_MEM_BEGIN = 5;
var ESP_MEM_END = 6;
var ESP_MEM_DATA = 7;
var ESP_SYNC = 8;
var ESP_WRITE_REG = 9;
var ESP_READ_REG = 10;
var ESP_ERASE_FLASH = 208;
var ESP_READ_FLASH = 210;
var ESP_SPI_ATTACH = 13;
var ESP_CHANGE_BAUDRATE = 15;
var ESP_GET_SECURITY_INFO = 20;
var ESP_CHECKSUM_MAGIC = 239;
var ESP_FLASH_DEFL_BEGIN = 16;
var ESP_FLASH_DEFL_DATA = 17;
var ESP_FLASH_DEFL_END = 18;
var ROM_INVALID_RECV_MSG = 5;
var USB_RAM_BLOCK = 2048;
var DEFAULT_TIMEOUT = 3e3;
var CHIP_ERASE_TIMEOUT = 15e4;
var MAX_TIMEOUT = CHIP_ERASE_TIMEOUT * 2;
var SYNC_TIMEOUT = 100;
var ERASE_REGION_TIMEOUT_PER_MB = 3e4;
var MEM_END_ROM_TIMEOUT = 500;
var FLASH_READ_TIMEOUT = 100;
var timeoutPerMb = (secondsPerMb, sizeBytes) => {
  const result = Math.floor(secondsPerMb * (sizeBytes / 486));
  if (result < DEFAULT_TIMEOUT) {
    return DEFAULT_TIMEOUT;
  }
  return result;
};
var getSpiFlashAddresses = (chipFamily) => {
  switch (chipFamily) {
    case CHIP_FAMILY_ESP32:
      return {
        regBase: ESP32_SPI_REG_BASE,
        baseFuse: ESP32_BASEFUSEADDR,
        macFuse: ESP32_MACFUSEADDR,
        usrOffs: ESP32_SPI_USR_OFFS,
        usr1Offs: ESP32_SPI_USR1_OFFS,
        usr2Offs: ESP32_SPI_USR2_OFFS,
        mosiDlenOffs: ESP32_SPI_MOSI_DLEN_OFFS,
        misoDlenOffs: ESP32_SPI_MISO_DLEN_OFFS,
        w0Offs: ESP32_SPI_W0_OFFS,
        uartDateReg: ESP32_UART_DATE_REG_ADDR,
        flashOffs: ESP32_BOOTLOADER_FLASH_OFFSET
      };
    case CHIP_FAMILY_ESP32S2:
      return {
        regBase: ESP32S2_SPI_REG_BASE,
        baseFuse: ESP32S2_BASEFUSEADDR,
        macFuse: ESP32S2_MACFUSEADDR,
        usrOffs: ESP32S2_SPI_USR_OFFS,
        usr1Offs: ESP32S2_SPI_USR1_OFFS,
        usr2Offs: ESP32S2_SPI_USR2_OFFS,
        mosiDlenOffs: ESP32S2_SPI_MOSI_DLEN_OFFS,
        misoDlenOffs: ESP32S2_SPI_MISO_DLEN_OFFS,
        w0Offs: ESP32S2_SPI_W0_OFFS,
        uartDateReg: ESP32S2_UART_DATE_REG_ADDR,
        flashOffs: ESP32S2_BOOTLOADER_FLASH_OFFSET
      };
    case CHIP_FAMILY_ESP32S3:
      return {
        regBase: ESP32S3_SPI_REG_BASE,
        usrOffs: ESP32S3_SPI_USR_OFFS,
        baseFuse: ESP32S3_BASEFUSEADDR,
        macFuse: ESP32S3_MACFUSEADDR,
        usr1Offs: ESP32S3_SPI_USR1_OFFS,
        usr2Offs: ESP32S3_SPI_USR2_OFFS,
        mosiDlenOffs: ESP32S3_SPI_MOSI_DLEN_OFFS,
        misoDlenOffs: ESP32S3_SPI_MISO_DLEN_OFFS,
        w0Offs: ESP32S3_SPI_W0_OFFS,
        uartDateReg: ESP32S3_UART_DATE_REG_ADDR,
        flashOffs: ESP32S3_BOOTLOADER_FLASH_OFFSET
      };
    case CHIP_FAMILY_ESP8266:
      return {
        regBase: ESP8266_SPI_REG_BASE,
        usrOffs: ESP8266_SPI_USR_OFFS,
        baseFuse: ESP8266_BASEFUSEADDR,
        macFuse: ESP8266_MACFUSEADDR,
        usr1Offs: ESP8266_SPI_USR1_OFFS,
        usr2Offs: ESP8266_SPI_USR2_OFFS,
        mosiDlenOffs: ESP8266_SPI_MOSI_DLEN_OFFS,
        misoDlenOffs: ESP8266_SPI_MISO_DLEN_OFFS,
        w0Offs: ESP8266_SPI_W0_OFFS,
        uartDateReg: ESP8266_UART_DATE_REG_ADDR,
        flashOffs: ESP8266_BOOTLOADER_FLASH_OFFSET
      };
    case CHIP_FAMILY_ESP32C2:
      return {
        regBase: ESP32C2_SPI_REG_BASE,
        baseFuse: ESP32C2_BASEFUSEADDR,
        macFuse: ESP32C2_MACFUSEADDR,
        usrOffs: ESP32C2_SPI_USR_OFFS,
        usr1Offs: ESP32C2_SPI_USR1_OFFS,
        usr2Offs: ESP32C2_SPI_USR2_OFFS,
        mosiDlenOffs: ESP32C2_SPI_MOSI_DLEN_OFFS,
        misoDlenOffs: ESP32C2_SPI_MISO_DLEN_OFFS,
        w0Offs: ESP32C2_SPI_W0_OFFS,
        uartDateReg: ESP32C2_UART_DATE_REG_ADDR,
        flashOffs: ESP32C2_BOOTLOADER_FLASH_OFFSET
      };
    case CHIP_FAMILY_ESP32C3:
      return {
        regBase: ESP32C3_SPI_REG_BASE,
        baseFuse: ESP32C3_BASEFUSEADDR,
        macFuse: ESP32C3_MACFUSEADDR,
        usrOffs: ESP32C3_SPI_USR_OFFS,
        usr1Offs: ESP32C3_SPI_USR1_OFFS,
        usr2Offs: ESP32C3_SPI_USR2_OFFS,
        mosiDlenOffs: ESP32C3_SPI_MOSI_DLEN_OFFS,
        misoDlenOffs: ESP32C3_SPI_MISO_DLEN_OFFS,
        w0Offs: ESP32C3_SPI_W0_OFFS,
        uartDateReg: ESP32C3_UART_DATE_REG_ADDR,
        flashOffs: ESP32C3_BOOTLOADER_FLASH_OFFSET
      };
    case CHIP_FAMILY_ESP32C5:
      return {
        regBase: ESP32C5_SPI_REG_BASE,
        baseFuse: ESP32C5_BASEFUSEADDR,
        macFuse: ESP32C5_MACFUSEADDR,
        usrOffs: ESP32C5_SPI_USR_OFFS,
        usr1Offs: ESP32C5_SPI_USR1_OFFS,
        usr2Offs: ESP32C5_SPI_USR2_OFFS,
        mosiDlenOffs: ESP32C5_SPI_MOSI_DLEN_OFFS,
        misoDlenOffs: ESP32C5_SPI_MISO_DLEN_OFFS,
        w0Offs: ESP32C5_SPI_W0_OFFS,
        uartDateReg: ESP32C5_UART_DATE_REG_ADDR,
        flashOffs: ESP32C5_BOOTLOADER_FLASH_OFFSET
      };
    case CHIP_FAMILY_ESP32C6:
      return {
        regBase: ESP32C6_SPI_REG_BASE,
        baseFuse: ESP32C6_BASEFUSEADDR,
        macFuse: ESP32C6_MACFUSEADDR,
        usrOffs: ESP32C6_SPI_USR_OFFS,
        usr1Offs: ESP32C6_SPI_USR1_OFFS,
        usr2Offs: ESP32C6_SPI_USR2_OFFS,
        mosiDlenOffs: ESP32C6_SPI_MOSI_DLEN_OFFS,
        misoDlenOffs: ESP32C6_SPI_MISO_DLEN_OFFS,
        w0Offs: ESP32C6_SPI_W0_OFFS,
        uartDateReg: ESP32C6_UART_DATE_REG_ADDR,
        flashOffs: ESP32C6_BOOTLOADER_FLASH_OFFSET
      };
    case CHIP_FAMILY_ESP32C61:
      return {
        regBase: ESP32C61_SPI_REG_BASE,
        baseFuse: ESP32C61_BASEFUSEADDR,
        macFuse: ESP32C61_MACFUSEADDR,
        usrOffs: ESP32C61_SPI_USR_OFFS,
        usr1Offs: ESP32C61_SPI_USR1_OFFS,
        usr2Offs: ESP32C61_SPI_USR2_OFFS,
        mosiDlenOffs: ESP32C61_SPI_MOSI_DLEN_OFFS,
        misoDlenOffs: ESP32C61_SPI_MISO_DLEN_OFFS,
        w0Offs: ESP32C61_SPI_W0_OFFS,
        uartDateReg: ESP32C61_UART_DATE_REG_ADDR,
        flashOffs: ESP32C61_BOOTLOADER_FLASH_OFFSET
      };
    case CHIP_FAMILY_ESP32H2:
      return {
        regBase: ESP32H2_SPI_REG_BASE,
        baseFuse: ESP32H2_BASEFUSEADDR,
        macFuse: ESP32H2_MACFUSEADDR,
        usrOffs: ESP32H2_SPI_USR_OFFS,
        usr1Offs: ESP32H2_SPI_USR1_OFFS,
        usr2Offs: ESP32H2_SPI_USR2_OFFS,
        mosiDlenOffs: ESP32H2_SPI_MOSI_DLEN_OFFS,
        misoDlenOffs: ESP32H2_SPI_MISO_DLEN_OFFS,
        w0Offs: ESP32H2_SPI_W0_OFFS,
        uartDateReg: ESP32H2_UART_DATE_REG_ADDR,
        flashOffs: ESP32H2_BOOTLOADER_FLASH_OFFSET
      };
    case CHIP_FAMILY_ESP32H4:
      return {
        regBase: ESP32H4_SPI_REG_BASE,
        baseFuse: ESP32H4_BASEFUSEADDR,
        macFuse: ESP32H4_MACFUSEADDR,
        usrOffs: ESP32H4_SPI_USR_OFFS,
        usr1Offs: ESP32H4_SPI_USR1_OFFS,
        usr2Offs: ESP32H4_SPI_USR2_OFFS,
        mosiDlenOffs: ESP32H4_SPI_MOSI_DLEN_OFFS,
        misoDlenOffs: ESP32H4_SPI_MISO_DLEN_OFFS,
        w0Offs: ESP32H4_SPI_W0_OFFS,
        uartDateReg: ESP32H4_UART_DATE_REG_ADDR,
        flashOffs: ESP32H4_BOOTLOADER_FLASH_OFFSET
      };
    case CHIP_FAMILY_ESP32H21:
      return {
        regBase: ESP32H21_SPI_REG_BASE,
        baseFuse: ESP32H21_BASEFUSEADDR,
        macFuse: ESP32H21_MACFUSEADDR,
        usrOffs: ESP32H21_SPI_USR_OFFS,
        usr1Offs: ESP32H21_SPI_USR1_OFFS,
        usr2Offs: ESP32H21_SPI_USR2_OFFS,
        mosiDlenOffs: ESP32H21_SPI_MOSI_DLEN_OFFS,
        misoDlenOffs: ESP32H21_SPI_MISO_DLEN_OFFS,
        w0Offs: ESP32H21_SPI_W0_OFFS,
        uartDateReg: ESP32H21_UART_DATE_REG_ADDR,
        flashOffs: ESP32H21_BOOTLOADER_FLASH_OFFSET
      };
    case CHIP_FAMILY_ESP32P4:
      return {
        regBase: ESP32P4_SPI_REG_BASE,
        baseFuse: ESP32P4_BASEFUSEADDR,
        macFuse: ESP32P4_MACFUSEADDR,
        usrOffs: ESP32P4_SPI_USR_OFFS,
        usr1Offs: ESP32P4_SPI_USR1_OFFS,
        usr2Offs: ESP32P4_SPI_USR2_OFFS,
        mosiDlenOffs: ESP32P4_SPI_MOSI_DLEN_OFFS,
        misoDlenOffs: ESP32P4_SPI_MISO_DLEN_OFFS,
        w0Offs: ESP32P4_SPI_W0_OFFS,
        uartDateReg: ESP32P4_UART_DATE_REG_ADDR,
        flashOffs: ESP32P4_BOOTLOADER_FLASH_OFFSET
      };
    case CHIP_FAMILY_ESP32S31:
      return {
        regBase: ESP32S31_SPI_REG_BASE,
        baseFuse: ESP32S31_BASEFUSEADDR,
        macFuse: ESP32S31_MACFUSEADDR,
        usrOffs: ESP32S31_SPI_USR_OFFS,
        usr1Offs: ESP32S31_SPI_USR1_OFFS,
        usr2Offs: ESP32S31_SPI_USR2_OFFS,
        mosiDlenOffs: ESP32S31_SPI_MOSI_DLEN_OFFS,
        misoDlenOffs: ESP32S31_SPI_MISO_DLEN_OFFS,
        w0Offs: ESP32S31_SPI_W0_OFFS,
        uartDateReg: ESP32S31_UART_DATE_REG_ADDR,
        flashOffs: ESP32S31_BOOTLOADER_FLASH_OFFSET
      };
    default:
      return {
        regBase: -1,
        baseFuse: -1,
        macFuse: -1,
        usrOffs: -1,
        usr1Offs: -1,
        usr2Offs: -1,
        mosiDlenOffs: -1,
        misoDlenOffs: -1,
        w0Offs: -1,
        uartDateReg: -1,
        flashOffs: -1
      };
  }
};
var SlipReadError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SlipReadError";
  }
};

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/stubs/index.js
var getStubCode = async (chipFamily, chipRevision) => {
  let stubcode;
  if (chipFamily == CHIP_FAMILY_ESP32H4 || chipFamily == CHIP_FAMILY_ESP32H21 || chipFamily == CHIP_FAMILY_ESP32S31) {
    return null;
  }
  if (chipFamily == CHIP_FAMILY_ESP32) {
    stubcode = await Promise.resolve().then(() => __toESM(require_esp32(), 1));
  } else if (chipFamily == CHIP_FAMILY_ESP32S2) {
    stubcode = await Promise.resolve().then(() => __toESM(require_esp32s2(), 1));
  } else if (chipFamily == CHIP_FAMILY_ESP32S3) {
    stubcode = await Promise.resolve().then(() => __toESM(require_esp32s3(), 1));
  } else if (chipFamily == CHIP_FAMILY_ESP8266) {
    stubcode = await Promise.resolve().then(() => __toESM(require_esp8266(), 1));
  } else if (chipFamily == CHIP_FAMILY_ESP32C2) {
    stubcode = await Promise.resolve().then(() => __toESM(require_esp32c2(), 1));
  } else if (chipFamily == CHIP_FAMILY_ESP32C3) {
    stubcode = await Promise.resolve().then(() => __toESM(require_esp32c3(), 1));
  } else if (chipFamily == CHIP_FAMILY_ESP32C5) {
    stubcode = await Promise.resolve().then(() => __toESM(require_esp32c5(), 1));
  } else if (chipFamily == CHIP_FAMILY_ESP32C6) {
    stubcode = await Promise.resolve().then(() => __toESM(require_esp32c6(), 1));
  } else if (chipFamily == CHIP_FAMILY_ESP32C61) {
    stubcode = await Promise.resolve().then(() => __toESM(require_esp32c61(), 1));
  } else if (chipFamily == CHIP_FAMILY_ESP32H2) {
    stubcode = await Promise.resolve().then(() => __toESM(require_esp32h2(), 1));
  } else if (chipFamily == CHIP_FAMILY_ESP32P4) {
    if (chipRevision !== null && chipRevision !== void 0 && chipRevision >= 300) {
      stubcode = await Promise.resolve().then(() => __toESM(require_esp32p4r3(), 1));
    } else {
      stubcode = await Promise.resolve().then(() => __toESM(require_esp32p4(), 1));
    }
  }
  return {
    ...stubcode,
    text: toByteArray(atob(stubcode.text)),
    data: toByteArray(atob(stubcode.data))
  };
};

// temp_lib_v7_real/node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
var putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        /* falls through */
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        /* falls through */
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state.mode = COPY;
        /* falls through */
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var deflate_1 = deflate;

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/struct.js
var lut = {
  b: { u: DataView.prototype.getInt8, p: DataView.prototype.setInt8, bytes: 1 },
  B: {
    u: DataView.prototype.getUint8,
    p: DataView.prototype.setUint8,
    bytes: 1
  },
  h: {
    u: DataView.prototype.getInt16,
    p: DataView.prototype.setInt16,
    bytes: 2
  },
  H: {
    u: DataView.prototype.getUint16,
    p: DataView.prototype.setUint16,
    bytes: 2
  },
  i: {
    u: DataView.prototype.getInt32,
    p: DataView.prototype.setInt32,
    bytes: 4
  },
  I: {
    u: DataView.prototype.getUint32,
    p: DataView.prototype.setUint32,
    bytes: 4
  }
};
var pack = (format, ...data) => {
  let pointer = 0;
  if (format.replace(/[<>]/, "").length != data.length) {
    throw "Pack format to Argument count mismatch";
  }
  const bytes = [];
  let littleEndian = true;
  for (let i = 0; i < format.length; i++) {
    if (format[i] == "<") {
      littleEndian = true;
    } else if (format[i] == ">") {
      littleEndian = false;
    } else {
      pushBytes(format[i], data[pointer]);
      pointer++;
    }
  }
  function pushBytes(formatChar, value) {
    if (!(formatChar in lut)) {
      throw "Unhandled character '" + formatChar + "' in pack format";
    }
    const dataSize = lut[formatChar].bytes;
    const view = new DataView(new ArrayBuffer(dataSize));
    const dataViewFn = lut[formatChar].p.bind(view);
    dataViewFn(0, value, littleEndian);
    for (let i = 0; i < dataSize; i++) {
      bytes.push(view.getUint8(i));
    }
  }
  return bytes;
};
var unpack = (format, bytes) => {
  let pointer = 0;
  const data = [];
  let littleEndian = true;
  for (const c of format) {
    if (c == "<") {
      littleEndian = true;
    } else if (c == ">") {
      littleEndian = false;
    } else {
      pushData(c);
    }
  }
  function pushData(formatChar) {
    if (!(formatChar in lut)) {
      throw "Unhandled character '" + formatChar + "' in unpack format";
    }
    const dataSize = lut[formatChar].bytes;
    const view = new DataView(new ArrayBuffer(dataSize));
    for (let i = 0; i < dataSize; i++) {
      view.setUint8(i, bytes[pointer + i] & 255);
    }
    const dataViewFn = lut[formatChar].u.bind(view);
    data.push(dataViewFn(0, littleEndian));
    pointer += dataSize;
  }
  return data;
};

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/esp_loader.js
var ESPLoader = class extends EventTarget {
  constructor(port, logger, _parent) {
    super();
    this.port = port;
    this.logger = logger;
    this._parent = _parent;
    this.chipName = null;
    this.chipRevision = null;
    this.chipVariant = null;
    this._efuses = new Array(4).fill(0);
    this._flashsize = 4 * 1024 * 1024;
    this.debug = false;
    this.IS_STUB = false;
    this.connected = true;
    this.flashSize = null;
    this._currentBaudRate = ESP_ROM_BAUD;
    this._isESP32S2NativeUSB = false;
    this._initializationSucceeded = false;
    this.__commandLock = Promise.resolve([0, []]);
    this.__isReconfiguring = false;
    this.state_DTR = false;
    this.__writeChain = Promise.resolve();
  }
  get _inputBuffer() {
    return this._parent ? this._parent._inputBuffer : this.__inputBuffer;
  }
  get _totalBytesRead() {
    return this._parent ? this._parent._totalBytesRead : this.__totalBytesRead || 0;
  }
  set _totalBytesRead(value) {
    if (this._parent) {
      this._parent._totalBytesRead = value;
    } else {
      this.__totalBytesRead = value;
    }
  }
  get _commandLock() {
    return this._parent ? this._parent._commandLock : this.__commandLock;
  }
  set _commandLock(value) {
    if (this._parent) {
      this._parent._commandLock = value;
    } else {
      this.__commandLock = value;
    }
  }
  get _isReconfiguring() {
    return this._parent ? this._parent._isReconfiguring : this.__isReconfiguring;
  }
  set _isReconfiguring(value) {
    if (this._parent) {
      this._parent._isReconfiguring = value;
    } else {
      this.__isReconfiguring = value;
    }
  }
  detectUSBSerialChip(vendorId, productId) {
    const chips = {
      6790: {
        // QinHeng Electronics
        29986: { name: "CH340", maxBaudrate: 460800 },
        29987: { name: "CH340", maxBaudrate: 460800 },
        30084: { name: "CH340", maxBaudrate: 460800 },
        21795: { name: "CH341", maxBaudrate: 2e6 },
        21971: { name: "CH343", maxBaudrate: 6e6 },
        21972: { name: "CH9102", maxBaudrate: 6e6 },
        21976: { name: "CH9101", maxBaudrate: 3e6 }
      },
      4292: {
        // Silicon Labs
        6e4: { name: "CP2102(n)", maxBaudrate: 3e6 },
        60016: { name: "CP2105", maxBaudrate: 2e6 },
        60017: { name: "CP2108", maxBaudrate: 2e6 }
      },
      1027: {
        // FTDI
        24577: { name: "FT232R", maxBaudrate: 3e6 },
        24592: { name: "FT2232", maxBaudrate: 3e6 },
        24593: { name: "FT4232", maxBaudrate: 3e6 },
        24596: { name: "FT232H", maxBaudrate: 12e6 },
        24597: { name: "FT230X", maxBaudrate: 3e6 }
      },
      12346: {
        // Espressif (native USB)
        2: { name: "ESP32-S2 Native USB", maxBaudrate: 2e6 },
        4097: { name: "ESP32 Native USB", maxBaudrate: 2e6 },
        4098: { name: "ESP32 Native USB", maxBaudrate: 2e6 },
        16386: { name: "ESP32 Native USB", maxBaudrate: 2e6 },
        4096: { name: "ESP32 Native USB", maxBaudrate: 2e6 }
      }
    };
    const vendor = chips[vendorId];
    if (vendor && vendor[productId]) {
      return vendor[productId];
    }
    return {
      name: `Unknown (VID: 0x${vendorId.toString(16)}, PID: 0x${productId.toString(16)})`
    };
  }
  async initialize() {
    if (!this._parent) {
      this.__inputBuffer = [];
      this.__totalBytesRead = 0;
      const portInfo = this.port.getInfo();
      if (portInfo.usbVendorId && portInfo.usbProductId) {
        const chipInfo = this.detectUSBSerialChip(portInfo.usbVendorId, portInfo.usbProductId);
        this.logger.log(`USB-Serial: ${chipInfo.name} (VID: 0x${portInfo.usbVendorId.toString(16)}, PID: 0x${portInfo.usbProductId.toString(16)})`);
        if (chipInfo.maxBaudrate) {
          this._maxUSBSerialBaudrate = chipInfo.maxBaudrate;
          this.logger.log(`Max baudrate: ${chipInfo.maxBaudrate}`);
        }
        if (portInfo.usbVendorId === 12346 && portInfo.usbProductId === 2) {
          this._isESP32S2NativeUSB = true;
        }
      }
      this.readLoop();
    }
    await this.connectWithResetStrategies();
    await this.detectChip();
    const FlAddr = getSpiFlashAddresses(this.getChipFamily());
    const AddrMAC = FlAddr.macFuse;
    for (let i = 0; i < 4; i++) {
      this._efuses[i] = await this.readRegister(AddrMAC + 4 * i);
    }
    this.logger.log(`Chip type ${this.chipName}`);
    this.logger.debug(`Bootloader flash offset: 0x${FlAddr.flashOffs.toString(16)}`);
    this._initializationSucceeded = true;
  }
  /**
   * Detect chip type using GET_SECURITY_INFO (for newer chips) or magic value (for older chips)
   */
  async detectChip() {
    try {
      const securityInfo = await this.getSecurityInfo();
      const chipId = securityInfo.chipId;
      const chipInfo = CHIP_ID_TO_INFO[chipId];
      if (chipInfo) {
        this.chipName = chipInfo.name;
        this.chipFamily = chipInfo.family;
        if (this.chipFamily === CHIP_FAMILY_ESP32P4) {
          this.chipRevision = await this.getChipRevision();
          this.logger.debug(`ESP32-P4 revision: ${this.chipRevision}`);
          if (this.chipRevision >= 300) {
            this.chipVariant = "rev300";
          } else {
            this.chipVariant = "rev0";
          }
          this.logger.debug(`ESP32-P4 variant: ${this.chipVariant}`);
        }
        this.logger.debug(`Detected chip via IMAGE_CHIP_ID: ${chipId} (${this.chipName})`);
        return;
      }
      this.logger.debug(`Unknown IMAGE_CHIP_ID: ${chipId}, falling back to magic value detection`);
    } catch (error) {
      this.logger.debug(`GET_SECURITY_INFO failed, using magic value detection: ${error}`);
      await this.drainInputBuffer(200);
      this._inputBuffer.length = 0;
      await sleep(SYNC_TIMEOUT);
      try {
        await this.sync();
      } catch (syncErr) {
        this.logger.debug(`Re-sync after GET_SECURITY_INFO failure: ${syncErr}`);
      }
    }
    const chipMagicValue = await this.readRegister(CHIP_DETECT_MAGIC_REG_ADDR);
    const chip = CHIP_DETECT_MAGIC_VALUES[chipMagicValue >>> 0];
    if (chip === void 0) {
      throw new Error(`Unknown Chip: Hex: ${toHex(chipMagicValue >>> 0, 8).toLowerCase()} Number: ${chipMagicValue}`);
    }
    this.chipName = chip.name;
    this.chipFamily = chip.family;
    if (this.chipFamily === CHIP_FAMILY_ESP32P4) {
      this.chipRevision = await this.getChipRevision();
      this.logger.debug(`ESP32-P4 revision: ${this.chipRevision}`);
      if (this.chipRevision >= 300) {
        this.chipVariant = "rev300";
      } else {
        this.chipVariant = "rev0";
      }
      this.logger.debug(`ESP32-P4 variant: ${this.chipVariant}`);
    }
    this.logger.debug(`Detected chip via magic value: ${toHex(chipMagicValue >>> 0, 8)} (${this.chipName})`);
  }
  /**
   * Get chip revision for ESP32-P4
   */
  async getChipRevision() {
    if (this.chipFamily !== CHIP_FAMILY_ESP32P4) {
      return 0;
    }
    const word2 = await this.readRegister(ESP32P4_EFUSE_BLOCK1_ADDR + 8);
    const minorRev = word2 & 15;
    const majorRev = (word2 >> 23 & 1) << 2 | word2 >> 4 & 3;
    return majorRev * 100 + minorRev;
  }
  /**
   * Get security info including chip ID (ESP32-C3 and later)
   */
  async getSecurityInfo() {
    const [, responseData] = await this.checkCommand(ESP_GET_SECURITY_INFO, [], 0);
    if (responseData.length === 0) {
      throw new Error(`GET_SECURITY_INFO not supported or returned empty response`);
    }
    if (responseData.length < 12) {
      throw new Error(`Invalid security info response length: ${responseData.length} (expected at least 12 bytes)`);
    }
    const flags = unpack("<I", responseData.slice(0, 4))[0];
    const flashCryptCnt = responseData[4];
    const keyPurposes = Array.from(responseData.slice(5, 12));
    const chipId = responseData.length >= 16 ? unpack("<I", responseData.slice(12, 16))[0] : 0;
    const apiVersion = responseData.length >= 20 ? unpack("<I", responseData.slice(16, 20))[0] : 0;
    return {
      flags,
      flashCryptCnt,
      keyPurposes,
      chipId,
      apiVersion
    };
  }
  /**
   * @name readLoop
   * Reads data from the input stream and places it in the inputBuffer
   */
  async readLoop() {
    if (this.debug) {
      this.logger.debug("Starting read loop");
    }
    this._reader = this.port.readable.getReader();
    try {
      let keepReading = true;
      while (keepReading) {
        const { value, done } = await this._reader.read();
        if (done) {
          this._reader.releaseLock();
          keepReading = false;
          break;
        }
        if (!value || value.length === 0) {
          continue;
        }
        const chunk = Array.from(value);
        Array.prototype.push.apply(this._inputBuffer, chunk);
        this._totalBytesRead += value.length;
      }
    } catch {
      this.logger.error("Read loop got disconnected");
    }
    this.connected = false;
    if (this._isESP32S2NativeUSB && !this._initializationSucceeded) {
      this.logger.log("ESP32-S2 Native USB detected - requesting port reselection");
      this.dispatchEvent(new CustomEvent("esp32s2-usb-reconnect", {
        detail: { message: "ESP32-S2 Native USB requires port reselection" }
      }));
    }
    this.dispatchEvent(new Event("disconnect"));
    this.logger.debug("Finished read loop");
  }
  sleep(ms = 100) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  async setRTS(state) {
    await this.port.setSignals({ requestToSend: state });
    await this.setDTR(this.state_DTR);
  }
  async setDTR(state) {
    this.state_DTR = state;
    await this.port.setSignals({ dataTerminalReady: state });
  }
  async hardReset(bootloader = false) {
    if (bootloader) {
      if (this.port.getInfo().usbProductId === USB_JTAG_SERIAL_PID) {
        await this.hardResetUSBJTAGSerial();
        this.logger.log("USB-JTAG/Serial reset.");
      } else {
        await this.hardResetClassic();
        this.logger.log("Classic reset.");
      }
    } else {
      await this.setRTS(true);
      await this.sleep(100);
      await this.setRTS(false);
      this.logger.log("Hard reset.");
    }
    await new Promise((resolve) => setTimeout(resolve, 1e3));
  }
  /**
   * @name macAddr
   * The MAC address burned into the OTP memory of the ESP chip
   */
  macAddr() {
    const macAddr = new Array(6).fill(0);
    const mac0 = this._efuses[0];
    const mac1 = this._efuses[1];
    const mac2 = this._efuses[2];
    const mac3 = this._efuses[3];
    let oui;
    if (this.chipFamily == CHIP_FAMILY_ESP8266) {
      if (mac3 != 0) {
        oui = [mac3 >> 16 & 255, mac3 >> 8 & 255, mac3 & 255];
      } else if ((mac1 >> 16 & 255) == 0) {
        oui = [24, 254, 52];
      } else if ((mac1 >> 16 & 255) == 1) {
        oui = [172, 208, 116];
      } else {
        throw new Error("Couldnt determine OUI");
      }
      macAddr[0] = oui[0];
      macAddr[1] = oui[1];
      macAddr[2] = oui[2];
      macAddr[3] = mac1 >> 8 & 255;
      macAddr[4] = mac1 & 255;
      macAddr[5] = mac0 >> 24 & 255;
    } else if (this.chipFamily == CHIP_FAMILY_ESP32) {
      macAddr[0] = mac2 >> 8 & 255;
      macAddr[1] = mac2 & 255;
      macAddr[2] = mac1 >> 24 & 255;
      macAddr[3] = mac1 >> 16 & 255;
      macAddr[4] = mac1 >> 8 & 255;
      macAddr[5] = mac1 & 255;
    } else if (this.chipFamily == CHIP_FAMILY_ESP32S2 || this.chipFamily == CHIP_FAMILY_ESP32S3 || this.chipFamily == CHIP_FAMILY_ESP32C2 || this.chipFamily == CHIP_FAMILY_ESP32C3 || this.chipFamily == CHIP_FAMILY_ESP32C5 || this.chipFamily == CHIP_FAMILY_ESP32C6 || this.chipFamily == CHIP_FAMILY_ESP32C61 || this.chipFamily == CHIP_FAMILY_ESP32H2 || this.chipFamily == CHIP_FAMILY_ESP32H4 || this.chipFamily == CHIP_FAMILY_ESP32H21 || this.chipFamily == CHIP_FAMILY_ESP32P4 || this.chipFamily == CHIP_FAMILY_ESP32S31) {
      macAddr[0] = mac1 >> 8 & 255;
      macAddr[1] = mac1 & 255;
      macAddr[2] = mac0 >> 24 & 255;
      macAddr[3] = mac0 >> 16 & 255;
      macAddr[4] = mac0 >> 8 & 255;
      macAddr[5] = mac0 & 255;
    } else {
      throw new Error("Unknown chip family");
    }
    return macAddr;
  }
  async readRegister(reg) {
    if (this.debug) {
      this.logger.debug("Reading from Register " + toHex(reg, 8));
    }
    const packet = pack("<I", reg);
    await this.sendCommand(ESP_READ_REG, packet);
    const [val] = await this.getResponse(ESP_READ_REG);
    return val;
  }
  /**
   * @name checkCommand
   * Send a command packet, check that the command succeeded and
   * return a tuple with the value and data.
   * See the ESP Serial Protocol for more details on what value/data are
   *
   * Commands are serialized to prevent concurrent execution which can cause
   * WritableStream lock contention on CP210x adapters under Windows
   */
  async checkCommand(opcode, buffer, checksum = 0, timeout = DEFAULT_TIMEOUT) {
    const executeCommand = async () => {
      timeout = Math.min(timeout, MAX_TIMEOUT);
      await this.sendCommand(opcode, buffer, checksum);
      const [value, responseData] = await this.getResponse(opcode, timeout);
      if (responseData === null) {
        throw new Error("Didn't get enough status bytes");
      }
      let data = responseData;
      let statusLen = 0;
      if (this.IS_STUB || this.chipFamily == CHIP_FAMILY_ESP8266) {
        statusLen = 2;
      } else if ([
        CHIP_FAMILY_ESP32,
        CHIP_FAMILY_ESP32S2,
        CHIP_FAMILY_ESP32S3,
        CHIP_FAMILY_ESP32C2,
        CHIP_FAMILY_ESP32C3,
        CHIP_FAMILY_ESP32C5,
        CHIP_FAMILY_ESP32C6,
        CHIP_FAMILY_ESP32C61,
        CHIP_FAMILY_ESP32H2,
        CHIP_FAMILY_ESP32H4,
        CHIP_FAMILY_ESP32H21,
        CHIP_FAMILY_ESP32P4,
        CHIP_FAMILY_ESP32S31
      ].includes(this.chipFamily)) {
        statusLen = 4;
      } else {
        if (opcode === ESP_GET_SECURITY_INFO) {
          statusLen = 4;
        } else if ([2, 4].includes(data.length)) {
          statusLen = data.length;
        }
      }
      if (data.length < statusLen) {
        throw new Error("Didn't get enough status bytes");
      }
      const status = data.slice(-statusLen, data.length);
      data = data.slice(0, -statusLen);
      if (this.debug) {
        this.logger.debug("status", status);
        this.logger.debug("value", value);
        this.logger.debug("data", data);
      }
      if (status[0] == 1) {
        if (status[1] == ROM_INVALID_RECV_MSG) {
          await this.drainInputBuffer(200);
          throw new Error("Invalid (unsupported) command " + toHex(opcode));
        } else {
          throw new Error("Command failure error code " + toHex(status[1]));
        }
      }
      return [value, data];
    };
    this._commandLock = this._commandLock.then(executeCommand, executeCommand);
    return this._commandLock;
  }
  /**
   * @name sendCommand
   * Send a slip-encoded, checksummed command over the UART,
   * does not check response
   */
  async sendCommand(opcode, buffer, checksum = 0) {
    const packet = slipEncode([
      ...pack("<BBHI", 0, opcode, buffer.length, checksum),
      ...buffer
    ]);
    if (this.debug) {
      this.logger.debug(`Writing ${packet.length} byte${packet.length == 1 ? "" : "s"}:`, packet);
    }
    await this.writeToStream(packet);
  }
  /**
   * @name readPacket
   * Generator to read SLIP packets from a serial port.
   * Yields one full SLIP packet at a time, raises exception on timeout or invalid data.
   */
  async readPacket(timeout) {
    let partialPacket = null;
    let inEscape = false;
    let readBytes = [];
    while (true) {
      const stamp = Date.now();
      readBytes = [];
      while (Date.now() - stamp < timeout) {
        if (this._inputBuffer.length > 0) {
          readBytes.push(this._inputBuffer.shift());
          break;
        } else {
          await sleep(1);
        }
      }
      if (readBytes.length == 0) {
        const waitingFor = partialPacket === null ? "header" : "content";
        throw new SlipReadError("Timed out waiting for packet " + waitingFor);
      }
      if (this.debug)
        this.logger.debug("Read " + readBytes.length + " bytes: " + hexFormatter(readBytes));
      for (const b of readBytes) {
        if (partialPacket === null) {
          if (b == 192) {
            partialPacket = [];
          } else {
            if (this.debug) {
              this.logger.debug("Read invalid data: " + toHex(b));
              this.logger.debug("Remaining data in serial buffer: " + hexFormatter(this._inputBuffer));
            }
            throw new SlipReadError("Invalid head of packet (" + toHex(b) + ")");
          }
        } else if (inEscape) {
          inEscape = false;
          if (b == 220) {
            partialPacket.push(192);
          } else if (b == 221) {
            partialPacket.push(219);
          } else {
            if (this.debug) {
              this.logger.debug("Read invalid data: " + toHex(b));
              this.logger.debug("Remaining data in serial buffer: " + hexFormatter(this._inputBuffer));
            }
            throw new SlipReadError("Invalid SLIP escape (0xdb, " + toHex(b) + ")");
          }
        } else if (b == 219) {
          inEscape = true;
        } else if (b == 192) {
          if (this.debug)
            this.logger.debug("Received full packet: " + hexFormatter(partialPacket));
          return partialPacket;
        } else {
          partialPacket.push(b);
        }
      }
    }
  }
  /**
   * @name getResponse
   * Read response data and decodes the slip packet, then parses
   * out the value/data and returns as a tuple of (value, data) where
   * each is a list of bytes
   */
  async getResponse(opcode, timeout = DEFAULT_TIMEOUT) {
    for (let i = 0; i < 100; i++) {
      const packet = await this.readPacket(timeout);
      if (packet.length < 8) {
        continue;
      }
      const [resp, opRet, , val] = unpack("<BBHI", packet.slice(0, 8));
      if (resp != 1) {
        continue;
      }
      const data = packet.slice(8);
      if (opcode == null || opRet == opcode) {
        return [val, data];
      }
      if (data[0] != 0 && data[1] == ROM_INVALID_RECV_MSG) {
        await this.drainInputBuffer(200);
        throw new Error(`Invalid (unsupported) command ${toHex(opcode)}`);
      }
    }
    throw "Response doesn't match request";
  }
  /**
   * @name checksum
   * Calculate checksum of a blob, as it is defined by the ROM
   */
  checksum(data, state = ESP_CHECKSUM_MAGIC) {
    for (const b of data) {
      state ^= b;
    }
    return state;
  }
  async setBaudrate(baud) {
    if (this.chipFamily == CHIP_FAMILY_ESP8266) {
      throw new Error("Changing baud rate is not supported on the ESP8266");
    }
    try {
      const buffer = pack("<II", baud, this.IS_STUB ? ESP_ROM_BAUD : 0);
      await this.checkCommand(ESP_CHANGE_BAUDRATE, buffer);
    } catch (e) {
      this.logger.error(`Baudrate change error: ${e}`);
      throw new Error(`Unable to change the baud rate to ${baud}: No response from set baud rate command.`);
    }
    if (this._parent) {
      await this._parent.reconfigurePort(baud);
    } else {
      await this.reconfigurePort(baud);
    }
    await sleep(SYNC_TIMEOUT);
    if (this._parent) {
      this._parent._currentBaudRate = baud;
    } else {
      this._currentBaudRate = baud;
    }
    const maxBaud = this._parent ? this._parent._maxUSBSerialBaudrate : this._maxUSBSerialBaudrate;
    if (maxBaud && baud > maxBaud) {
      this.logger.log(`\u26A0\uFE0F  WARNING: Baudrate ${baud} exceeds USB-Serial chip limit (${maxBaud})!`);
      this.logger.log(`\u26A0\uFE0F  This may cause data corruption or connection failures!`);
    }
    this.logger.log(`Changed baud rate to ${baud}`);
  }
  async reconfigurePort(baud) {
    var _a;
    try {
      try {
        await this._writeChain;
      } catch (err2) {
        this.logger.debug(`Pending write error during reconfigure: ${err2}`);
      }
      this._isReconfiguring = true;
      if (this._writer) {
        try {
          this._writer.releaseLock();
        } catch (err2) {
          this.logger.debug(`Writer release error during reconfigure: ${err2}`);
        }
        this._writer = void 0;
      }
      await ((_a = this._reader) === null || _a === void 0 ? void 0 : _a.cancel());
      await this.port.close();
      await this.port.open({ baudRate: baud });
      this._isReconfiguring = false;
      await this.flushSerialBuffers();
      this.readLoop();
    } catch (e) {
      this._isReconfiguring = false;
      this.logger.error(`Reconfigure port error: ${e}`);
      throw new Error(`Unable to change the baud rate to ${baud}: ${e}`);
    }
  }
  /**
   * @name connectWithResetStrategies
   * Try different reset strategies to enter bootloader mode
   * Similar to esptool.py's connect() method with multiple reset strategies
   */
  async connectWithResetStrategies() {
    var _a, _b;
    const portInfo = this.port.getInfo();
    const isUSBJTAGSerial = portInfo.usbProductId === USB_JTAG_SERIAL_PID;
    const isEspressifUSB = portInfo.usbVendorId === 12346;
    this.logger.log(`Detected USB: VID=0x${((_a = portInfo.usbVendorId) === null || _a === void 0 ? void 0 : _a.toString(16)) || "unknown"}, PID=0x${((_b = portInfo.usbProductId) === null || _b === void 0 ? void 0 : _b.toString(16)) || "unknown"}`);
    const resetStrategies = [];
    if (isUSBJTAGSerial || isEspressifUSB) {
      resetStrategies.push({
        name: "USB-JTAG/Serial",
        fn: async () => await this.hardResetUSBJTAGSerial()
      });
    }
    resetStrategies.push({
      name: "Classic",
      fn: async () => await this.hardResetClassic()
    });
    if (!isUSBJTAGSerial && !isEspressifUSB) {
      resetStrategies.push({
        name: "USB-JTAG/Serial (fallback)",
        fn: async () => await this.hardResetUSBJTAGSerial()
      });
    }
    let lastError = null;
    for (const strategy of resetStrategies) {
      try {
        this.logger.log(`Trying ${strategy.name} reset...`);
        if (!this.connected || !this.port.writable) {
          this.logger.log(`Port disconnected, skipping ${strategy.name} reset`);
          continue;
        }
        await strategy.fn();
        await this.sync();
        this.logger.log(`Connected successfully with ${strategy.name} reset.`);
        return;
      } catch (error) {
        lastError = error;
        this.logger.log(`${strategy.name} reset failed: ${error.message}`);
        if (!this.connected || !this.port.writable) {
          this.logger.log(`Port disconnected during reset attempt`);
          break;
        }
        this._inputBuffer.length = 0;
        await this.drainInputBuffer(200);
        await this.flushSerialBuffers();
      }
    }
    throw new Error(`Couldn't sync to ESP. Try resetting manually. Last error: ${lastError === null || lastError === void 0 ? void 0 : lastError.message}`);
  }
  /**
   * @name hardResetUSBJTAGSerial
   * USB-JTAG/Serial reset sequence for ESP32-C3, ESP32-S3, ESP32-C6, etc.
   */
  async hardResetUSBJTAGSerial() {
    await this.setRTS(false);
    await this.setDTR(false);
    await this.sleep(100);
    await this.setDTR(true);
    await this.setRTS(false);
    await this.sleep(100);
    await this.setRTS(true);
    await this.setDTR(false);
    await this.setRTS(true);
    await this.sleep(100);
    await this.setDTR(false);
    await this.setRTS(false);
    await this.sleep(200);
  }
  /**
   * @name hardResetClassic
   * Classic reset sequence for USB-to-Serial bridge chips (CH340, CP2102, etc.)
   */
  async hardResetClassic() {
    await this.setDTR(false);
    await this.setRTS(true);
    await this.sleep(100);
    await this.setDTR(true);
    await this.setRTS(false);
    await this.sleep(50);
    await this.setDTR(false);
    await this.sleep(200);
  }
  /**
   * @name sync
   * Put into ROM bootload mode & attempt to synchronize with the
   * ESP ROM bootloader, we will retry a few times
   */
  async sync() {
    for (let i = 0; i < 5; i++) {
      this._inputBuffer.length = 0;
      const response = await this._sync();
      if (response) {
        await sleep(SYNC_TIMEOUT);
        return true;
      }
      await sleep(SYNC_TIMEOUT);
    }
    throw new Error("Couldn't sync to ESP. Try resetting.");
  }
  /**
   * @name _sync
   * Perform a soft-sync using AT sync packets, does not perform
   * any hardware resetting
   */
  async _sync() {
    await this.sendCommand(ESP_SYNC, SYNC_PACKET);
    for (let i = 0; i < 8; i++) {
      try {
        const [, data] = await this.getResponse(ESP_SYNC, SYNC_TIMEOUT);
        if (data.length > 1 && data[0] == 0 && data[1] == 0) {
          return true;
        }
      } catch {
      }
    }
    return false;
  }
  /**
   * @name getFlashWriteSize
   * Get the Flash write size based on the chip
   */
  getFlashWriteSize() {
    if (this.IS_STUB) {
      return STUB_FLASH_WRITE_SIZE;
    }
    return FLASH_WRITE_SIZE;
  }
  /**
   * @name flashData
   * Program a full, uncompressed binary file into SPI Flash at
   *   a given offset. If an ESP32 and md5 string is passed in, will also
   *   verify memory. ESP8266 does not have checksum memory verification in
   *   ROM
   */
  async flashData(binaryData, updateProgress, offset = 0, compress = false) {
    if (binaryData.byteLength >= 8) {
      const header = Array.from(new Uint8Array(binaryData, 0, 4));
      const headerMagic = header[0];
      const headerFlashMode = header[2];
      const headerFlashSizeFreq = header[3];
      this.logger.log(`Image header, Magic=${toHex(headerMagic)}, FlashMode=${toHex(headerFlashMode)}, FlashSizeFreq=${toHex(headerFlashSizeFreq)}`);
    }
    const uncompressedFilesize = binaryData.byteLength;
    let compressedFilesize = 0;
    let dataToFlash;
    let timeout = DEFAULT_TIMEOUT;
    if (compress) {
      dataToFlash = deflate_1(new Uint8Array(binaryData), {
        level: 9
      }).buffer;
      compressedFilesize = dataToFlash.byteLength;
      this.logger.log(`Writing data with filesize: ${uncompressedFilesize}. Compressed Size: ${compressedFilesize}`);
      timeout = await this.flashDeflBegin(uncompressedFilesize, compressedFilesize, offset);
    } else {
      this.logger.log(`Writing data with filesize: ${uncompressedFilesize}`);
      dataToFlash = binaryData;
      await this.flashBegin(uncompressedFilesize, offset);
    }
    let block = [];
    let seq = 0;
    let written = 0;
    let position = 0;
    const stamp = Date.now();
    const flashWriteSize = this.getFlashWriteSize();
    const filesize = compress ? compressedFilesize : uncompressedFilesize;
    while (filesize - position > 0) {
      if (this.debug) {
        this.logger.log(`Writing at ${toHex(offset + seq * flashWriteSize, 8)} `);
      }
      if (filesize - position >= flashWriteSize) {
        block = Array.from(new Uint8Array(dataToFlash, position, flashWriteSize));
      } else {
        block = Array.from(new Uint8Array(dataToFlash, position, filesize - position));
        if (!compress) {
          block = block.concat(new Array(flashWriteSize - block.length).fill(255));
        }
      }
      if (compress) {
        await this.flashDeflBlock(block, seq, timeout);
      } else {
        await this.flashBlock(block, seq);
      }
      seq += 1;
      written += compress ? Math.round(block.length * uncompressedFilesize / compressedFilesize) : block.length;
      position += flashWriteSize;
      updateProgress(Math.min(written, uncompressedFilesize), uncompressedFilesize);
    }
    this.logger.log("Took " + (Date.now() - stamp) + "ms to write " + filesize + " bytes");
    if (this.IS_STUB) {
      await this.flashBegin(0, 0);
      if (compress) {
        await this.flashDeflFinish();
      } else {
        await this.flashFinish();
      }
    }
  }
  /**
   * @name flashBlock
   * Send one block of data to program into SPI Flash memory
   */
  async flashBlock(data, seq, timeout = DEFAULT_TIMEOUT) {
    await this.checkCommand(ESP_FLASH_DATA, pack("<IIII", data.length, seq, 0, 0).concat(data), this.checksum(data), timeout);
  }
  async flashDeflBlock(data, seq, timeout = DEFAULT_TIMEOUT) {
    await this.checkCommand(ESP_FLASH_DEFL_DATA, pack("<IIII", data.length, seq, 0, 0).concat(data), this.checksum(data), timeout);
  }
  /**
   * @name flashBegin
   * Prepare for flashing by attaching SPI chip and erasing the
   *   number of blocks requred.
   */
  async flashBegin(size = 0, offset = 0, encrypted = false) {
    await this.flushSerialBuffers();
    let eraseSize;
    const flashWriteSize = this.getFlashWriteSize();
    if (!this.IS_STUB && [
      CHIP_FAMILY_ESP32,
      CHIP_FAMILY_ESP32S2,
      CHIP_FAMILY_ESP32S3,
      CHIP_FAMILY_ESP32C2,
      CHIP_FAMILY_ESP32C3,
      CHIP_FAMILY_ESP32C5,
      CHIP_FAMILY_ESP32C6,
      CHIP_FAMILY_ESP32C61,
      CHIP_FAMILY_ESP32H2,
      CHIP_FAMILY_ESP32H4,
      CHIP_FAMILY_ESP32H21,
      CHIP_FAMILY_ESP32P4,
      CHIP_FAMILY_ESP32S31
    ].includes(this.chipFamily)) {
      await this.checkCommand(ESP_SPI_ATTACH, new Array(8).fill(0));
    }
    const numBlocks = Math.floor((size + flashWriteSize - 1) / flashWriteSize);
    if (this.chipFamily == CHIP_FAMILY_ESP8266) {
      eraseSize = this.getEraseSize(offset, size);
    } else {
      eraseSize = size;
    }
    const timeout = this.IS_STUB ? DEFAULT_TIMEOUT : timeoutPerMb(ERASE_REGION_TIMEOUT_PER_MB, size);
    const stamp = Date.now();
    let buffer = pack("<IIII", eraseSize, numBlocks, flashWriteSize, offset);
    if (this.chipFamily == CHIP_FAMILY_ESP32 || this.chipFamily == CHIP_FAMILY_ESP32S2 || this.chipFamily == CHIP_FAMILY_ESP32S3 || this.chipFamily == CHIP_FAMILY_ESP32C2 || this.chipFamily == CHIP_FAMILY_ESP32C3 || this.chipFamily == CHIP_FAMILY_ESP32C5 || this.chipFamily == CHIP_FAMILY_ESP32C6 || this.chipFamily == CHIP_FAMILY_ESP32C61 || this.chipFamily == CHIP_FAMILY_ESP32H2 || this.chipFamily == CHIP_FAMILY_ESP32H4 || this.chipFamily == CHIP_FAMILY_ESP32H21 || this.chipFamily == CHIP_FAMILY_ESP32P4 || this.chipFamily == CHIP_FAMILY_ESP32S31) {
      buffer = buffer.concat(pack("<I", encrypted ? 1 : 0));
    }
    this.logger.log("Erase size " + eraseSize + ", blocks " + numBlocks + ", block size " + toHex(flashWriteSize, 4) + ", offset " + toHex(offset, 4) + ", encrypted " + (encrypted ? "yes" : "no"));
    await this.checkCommand(ESP_FLASH_BEGIN, buffer, 0, timeout);
    if (size != 0 && !this.IS_STUB) {
      this.logger.log("Took " + (Date.now() - stamp) + "ms to erase " + numBlocks + " bytes");
    }
    return numBlocks;
  }
  /**
   * @name flashDeflBegin
   *
   */
  async flashDeflBegin(size = 0, compressedSize = 0, offset = 0) {
    const flashWriteSize = this.getFlashWriteSize();
    const numBlocks = Math.floor((compressedSize + flashWriteSize - 1) / flashWriteSize);
    const eraseBlocks = Math.floor((size + flashWriteSize - 1) / flashWriteSize);
    let writeSize = 0;
    let timeout = 0;
    if (this.IS_STUB) {
      writeSize = size;
      timeout = timeoutPerMb(ERASE_REGION_TIMEOUT_PER_MB, writeSize);
    } else {
      writeSize = eraseBlocks * flashWriteSize;
      timeout = DEFAULT_TIMEOUT;
    }
    const buffer = pack("<IIII", writeSize, numBlocks, flashWriteSize, offset);
    await this.checkCommand(ESP_FLASH_DEFL_BEGIN, buffer, 0, timeout);
    return timeout;
  }
  async flashFinish() {
    const buffer = pack("<I", 1);
    await this.checkCommand(ESP_FLASH_END, buffer);
  }
  async flashDeflFinish() {
    const buffer = pack("<I", 1);
    await this.checkCommand(ESP_FLASH_DEFL_END, buffer);
  }
  getBootloaderOffset() {
    const bootFlashOffs = getSpiFlashAddresses(this.getChipFamily());
    const BootldrFlashOffs = bootFlashOffs.flashOffs;
    return BootldrFlashOffs;
  }
  async flashId() {
    const SPIFLASH_RDID = 159;
    const result = await this.runSpiFlashCommand(SPIFLASH_RDID, [], 24);
    return result;
  }
  getChipFamily() {
    return this._parent ? this._parent.chipFamily : this.chipFamily;
  }
  async writeRegister(address, value, mask = 4294967295, delayUs = 0, delayAfterUs = 0) {
    let buffer = pack("<IIII", address, value, mask, delayUs);
    if (delayAfterUs > 0) {
      buffer = buffer.concat(pack("<IIII", getSpiFlashAddresses(this.getChipFamily()).uartDateReg, 0, 0, delayAfterUs));
    }
    await this.checkCommand(ESP_WRITE_REG, buffer);
  }
  async setDataLengths(spiAddresses, mosiBits, misoBits) {
    if (spiAddresses.mosiDlenOffs != -1) {
      const SPI_MOSI_DLEN_REG = spiAddresses.regBase + spiAddresses.mosiDlenOffs;
      const SPI_MISO_DLEN_REG = spiAddresses.regBase + spiAddresses.misoDlenOffs;
      if (mosiBits > 0) {
        await this.writeRegister(SPI_MOSI_DLEN_REG, mosiBits - 1);
      }
      if (misoBits > 0) {
        await this.writeRegister(SPI_MISO_DLEN_REG, misoBits - 1);
      }
    } else {
      const SPI_DATA_LEN_REG = spiAddresses.regBase + spiAddresses.usr1Offs;
      const SPI_MOSI_BITLEN_S = 17;
      const SPI_MISO_BITLEN_S = 8;
      const mosiMask = mosiBits == 0 ? 0 : mosiBits - 1;
      const misoMask = misoBits == 0 ? 0 : misoBits - 1;
      const value = misoMask << SPI_MISO_BITLEN_S | mosiMask << SPI_MOSI_BITLEN_S;
      await this.writeRegister(SPI_DATA_LEN_REG, value);
    }
  }
  async waitDone(spiCmdReg, spiCmdUsr) {
    for (let i = 0; i < 10; i++) {
      const cmdValue = await this.readRegister(spiCmdReg);
      if ((cmdValue & spiCmdUsr) == 0) {
        return;
      }
    }
    throw Error("SPI command did not complete in time");
  }
  async runSpiFlashCommand(spiflashCommand, data, readBits = 0) {
    const SPI_USR_COMMAND = 1 << 31;
    const SPI_USR_MISO = 1 << 28;
    const SPI_USR_MOSI = 1 << 27;
    const spiAddresses = getSpiFlashAddresses(this.getChipFamily());
    const base = spiAddresses.regBase;
    const SPI_CMD_REG = base;
    const SPI_USR_REG = base + spiAddresses.usrOffs;
    const SPI_USR2_REG = base + spiAddresses.usr2Offs;
    const SPI_W0_REG = base + spiAddresses.w0Offs;
    const SPI_CMD_USR = 1 << 18;
    const SPI_USR2_COMMAND_LEN_SHIFT = 28;
    if (readBits > 32) {
      throw new Error("Reading more than 32 bits back from a SPI flash operation is unsupported");
    }
    if (data.length > 64) {
      throw new Error("Writing more than 64 bytes of data with one SPI command is unsupported");
    }
    const dataBits = data.length * 8;
    const oldSpiUsr = await this.readRegister(SPI_USR_REG);
    const oldSpiUsr2 = await this.readRegister(SPI_USR2_REG);
    let flags = SPI_USR_COMMAND;
    if (readBits > 0) {
      flags |= SPI_USR_MISO;
    }
    if (dataBits > 0) {
      flags |= SPI_USR_MOSI;
    }
    await this.setDataLengths(spiAddresses, dataBits, readBits);
    await this.writeRegister(SPI_USR_REG, flags);
    await this.writeRegister(SPI_USR2_REG, 7 << SPI_USR2_COMMAND_LEN_SHIFT | spiflashCommand);
    if (dataBits == 0) {
      await this.writeRegister(SPI_W0_REG, 0);
    } else {
      const padLen = (4 - data.length % 4) % 4;
      data = data.concat(new Array(padLen).fill(0));
      const words = unpack("I".repeat(Math.floor(data.length / 4)), data);
      let nextReg = SPI_W0_REG;
      this.logger.debug(`Words Length: ${words.length}`);
      for (const word of words) {
        this.logger.debug(`Writing word ${toHex(word)} to register offset ${toHex(nextReg)}`);
        await this.writeRegister(nextReg, word);
        nextReg += 4;
      }
    }
    await this.writeRegister(SPI_CMD_REG, SPI_CMD_USR);
    await this.waitDone(SPI_CMD_REG, SPI_CMD_USR);
    const status = await this.readRegister(SPI_W0_REG);
    await this.writeRegister(SPI_USR_REG, oldSpiUsr);
    await this.writeRegister(SPI_USR2_REG, oldSpiUsr2);
    return status;
  }
  async detectFlashSize() {
    this.logger.log("Detecting Flash Size");
    const flashId = await this.flashId();
    const manufacturer = flashId & 255;
    const flashIdLowbyte = flashId >> 16 & 255;
    this.logger.log(`FlashId: ${toHex(flashId)}`);
    this.logger.log(`Flash Manufacturer: ${manufacturer.toString(16)}`);
    this.logger.log(`Flash Device: ${(flashId >> 8 & 255).toString(16)}${flashIdLowbyte.toString(16)}`);
    this.flashSize = DETECTED_FLASH_SIZES[flashIdLowbyte];
    this.logger.log(`Auto-detected Flash size: ${this.flashSize}`);
  }
  /**
   * @name getEraseSize
   * Calculate an erase size given a specific size in bytes.
   *   Provides a workaround for the bootloader erase bug on ESP8266.
   */
  getEraseSize(offset, size) {
    const sectorsPerBlock = 16;
    const sectorSize = FLASH_SECTOR_SIZE;
    const numSectors = Math.floor((size + sectorSize - 1) / sectorSize);
    const startSector = Math.floor(offset / sectorSize);
    let headSectors = sectorsPerBlock - startSector % sectorsPerBlock;
    if (numSectors < headSectors) {
      headSectors = numSectors;
    }
    if (numSectors < 2 * headSectors) {
      return Math.floor((numSectors + 1) / 2 * sectorSize);
    }
    return (numSectors - headSectors) * sectorSize;
  }
  /**
   * @name memBegin (592)
   * Start downloading an application image to RAM
   */
  async memBegin(size, blocks, blocksize, offset) {
    return await this.checkCommand(ESP_MEM_BEGIN, pack("<IIII", size, blocks, blocksize, offset));
  }
  /**
   * @name memBlock (609)
   * Send a block of an image to RAM
   */
  async memBlock(data, seq) {
    return await this.checkCommand(ESP_MEM_DATA, pack("<IIII", data.length, seq, 0, 0).concat(data), this.checksum(data));
  }
  /**
   * @name memFinish (615)
   * Leave download mode and run the application
   *
   * Sending ESP_MEM_END usually sends a correct response back, however sometimes
   * (with ROM loader) the executed code may reset the UART or change the baud rate
   * before the transmit FIFO is empty. So in these cases we set a short timeout and
   * ignore errors.
   */
  async memFinish(entrypoint = 0) {
    const timeout = this.IS_STUB ? DEFAULT_TIMEOUT : MEM_END_ROM_TIMEOUT;
    const data = pack("<II", entrypoint == 0 ? 1 : 0, entrypoint);
    return await this.checkCommand(ESP_MEM_END, data, 0, timeout);
  }
  async runStub(skipFlashDetection = false) {
    const stub = await getStubCode(this.chipFamily, this.chipRevision);
    if (stub === null) {
      this.logger.log(`Stub flasher is not yet supported on ${this.chipName}, using ROM loader`);
      return this;
    }
    const ramBlock = USB_RAM_BLOCK;
    this.logger.log("Uploading stub...");
    for (const field of ["text", "data"]) {
      const fieldData = stub[field];
      const offset = stub[`${field}_start`];
      const length = fieldData.length;
      const blocks = Math.floor((length + ramBlock - 1) / ramBlock);
      await this.memBegin(length, blocks, ramBlock, offset);
      for (const seq of Array(blocks).keys()) {
        const fromOffs = seq * ramBlock;
        let toOffs = fromOffs + ramBlock;
        if (toOffs > length) {
          toOffs = length;
        }
        await this.memBlock(fieldData.slice(fromOffs, toOffs), seq);
      }
    }
    await this.memFinish(stub.entry);
    const p = await this.readPacket(500);
    const pChar = String.fromCharCode(...p);
    if (pChar != "OHAI") {
      throw new Error("Failed to start stub. Unexpected response: " + pChar);
    }
    this.logger.log("Stub is now running...");
    const espStubLoader = new EspStubLoader(this.port, this.logger, this);
    if (!skipFlashDetection) {
      await espStubLoader.detectFlashSize();
    }
    return espStubLoader;
  }
  get _writer() {
    return this._parent ? this._parent._writer : this.__writer;
  }
  set _writer(value) {
    if (this._parent) {
      this._parent._writer = value;
    } else {
      this.__writer = value;
    }
  }
  get _writeChain() {
    return this._parent ? this._parent._writeChain : this.__writeChain;
  }
  set _writeChain(value) {
    if (this._parent) {
      this._parent._writeChain = value;
    } else {
      this.__writeChain = value;
    }
  }
  async writeToStream(data) {
    if (!this.port.writable) {
      this.logger.debug("Port writable stream not available, skipping write");
      return;
    }
    if (this._isReconfiguring) {
      throw new Error("Cannot write during port reconfiguration");
    }
    this._writeChain = this._writeChain.then(async () => {
      if (!this.port.writable) {
        throw new Error("Port became unavailable during write");
      }
      if (!this._writer) {
        try {
          this._writer = this.port.writable.getWriter();
        } catch (err2) {
          this.logger.error(`Failed to get writer: ${err2}`);
          throw err2;
        }
      }
      await this._writer.write(new Uint8Array(data));
    }, async () => {
      if (!this.port.writable) {
        throw new Error("Port became unavailable during write");
      }
      if (!this._writer) {
        this._writer = this.port.writable.getWriter();
      }
      await this._writer.write(new Uint8Array(data));
    }).catch((err2) => {
      this.logger.error(`Write error: ${err2}`);
      if (this._writer) {
        try {
          this._writer.releaseLock();
        } catch (e) {
        }
        this._writer = void 0;
      }
      throw err2;
    });
    await this._writeChain;
  }
  async disconnect() {
    if (this._parent) {
      await this._parent.disconnect();
      return;
    }
    if (!this.port.writable) {
      this.logger.debug("Port already closed, skipping disconnect");
      return;
    }
    try {
      try {
        await this._writeChain;
      } catch (err2) {
        this.logger.debug(`Pending write error during disconnect: ${err2}`);
      }
      this._isReconfiguring = true;
      if (this._writer) {
        try {
          await this._writer.close();
          this._writer.releaseLock();
        } catch (err2) {
          this.logger.debug(`Writer close/release error: ${err2}`);
        }
        this._writer = void 0;
      } else {
        try {
          const writer = this.port.writable.getWriter();
          await writer.close();
          writer.releaseLock();
        } catch (err2) {
          this.logger.debug(`Direct writer close error: ${err2}`);
        }
      }
      await new Promise((resolve) => {
        if (!this._reader) {
          resolve(void 0);
        }
        this.addEventListener("disconnect", resolve, { once: true });
        this._reader.cancel();
      });
      this.connected = false;
    } finally {
      this._isReconfiguring = false;
    }
  }
  /**
   * @name reconnectAndResume
   * Reconnect the serial port to flush browser buffers and reload stub
   */
  async reconnect() {
    if (this._parent) {
      await this._parent.reconnect();
      return;
    }
    try {
      this.logger.log("Reconnecting serial port...");
      this.connected = false;
      this.__inputBuffer = [];
      try {
        await this._writeChain;
      } catch (err2) {
        this.logger.debug(`Pending write error during reconnect: ${err2}`);
      }
      this._isReconfiguring = true;
      if (this._writer) {
        try {
          this._writer.releaseLock();
        } catch (err2) {
          this.logger.debug(`Writer release error during reconnect: ${err2}`);
        }
        this._writer = void 0;
      }
      if (this._reader) {
        try {
          await this._reader.cancel();
        } catch (err2) {
          this.logger.debug(`Reader cancel error: ${err2}`);
        }
        this._reader = void 0;
      }
      try {
        await this.port.close();
        this.logger.log("Port closed");
      } catch (err2) {
        this.logger.debug(`Port close error: ${err2}`);
      }
      this.logger.debug("Opening port...");
      try {
        await this.port.open({ baudRate: ESP_ROM_BAUD });
        this.connected = true;
      } catch (err2) {
        throw new Error(`Failed to open port: ${err2}`);
      }
      if (!this.port.readable || !this.port.writable) {
        throw new Error(`Port streams not available after open (readable: ${!!this.port.readable}, writable: ${!!this.port.writable})`);
      }
      this._isReconfiguring = false;
      const savedChipFamily = this.chipFamily;
      const savedChipName = this.chipName;
      const savedChipRevision = this.chipRevision;
      const savedChipVariant = this.chipVariant;
      const savedFlashSize = this.flashSize;
      await this.hardReset(true);
      if (!this._parent) {
        this.__inputBuffer = [];
        this.__totalBytesRead = 0;
        this.readLoop();
      }
      await this.flushSerialBuffers();
      await this.sync();
      this.chipFamily = savedChipFamily;
      this.chipName = savedChipName;
      this.chipRevision = savedChipRevision;
      this.chipVariant = savedChipVariant;
      this.flashSize = savedFlashSize;
      this.logger.debug(`Reconnect complete (chip: ${this.chipName})`);
      if (!this.port.writable || !this.port.readable) {
        throw new Error("Port not ready after reconnect");
      }
      const stubLoader = await this.runStub(true);
      this.logger.debug("Stub loaded");
      if (this._currentBaudRate !== ESP_ROM_BAUD) {
        await stubLoader.setBaudrate(this._currentBaudRate);
        if (!this.port.writable || !this.port.readable) {
          throw new Error(`Port not ready after baudrate change (readable: ${!!this.port.readable}, writable: ${!!this.port.writable})`);
        }
      }
      if (this.IS_STUB) {
        Object.assign(this, stubLoader);
      }
      this.logger.debug("Reconnection successful");
    } catch (err2) {
      this._isReconfiguring = false;
      throw err2;
    }
  }
  /**
   * @name drainInputBuffer
   * Actively drain the input buffer by reading data for a specified time.
   * Simple approach for some drivers (especially CP210x on Windows) that have
   * issues with buffer flushing.
   *
   * Based on esptool.py fix: https://github.com/espressif/esptool/commit/5338ea054e5099ac7be235c54034802ac8a43162
   *
   * @param bufferingTime - Time in milliseconds to wait for the buffer to fill
   */
  async drainInputBuffer(bufferingTime = 200) {
    await sleep(bufferingTime);
    const bytesToDrain = 14 * 8;
    let drained = 0;
    const drainStart = Date.now();
    const drainTimeout = 100;
    while (drained < bytesToDrain && Date.now() - drainStart < drainTimeout) {
      if (this._inputBuffer.length > 0) {
        const byte = this._inputBuffer.shift();
        if (byte !== void 0) {
          drained++;
        }
      } else {
        await sleep(1);
      }
    }
    if (drained > 0) {
      this.logger.debug(`Drained ${drained} bytes from input buffer`);
    }
    if (!this._parent) {
      this.__inputBuffer = [];
    }
  }
  /**
   * @name flushSerialBuffers
   * Flush any pending data in the TX and RX serial port buffers
   * This clears both the application RX buffer and waits for hardware buffers to drain
   */
  async flushSerialBuffers() {
    if (!this._parent) {
      this.__inputBuffer = [];
    }
    await sleep(SYNC_TIMEOUT);
    if (!this._parent) {
      this.__inputBuffer = [];
    }
    this.logger.debug("Serial buffers flushed");
  }
  /**
   * @name readFlash
   * Read flash memory from the chip (only works with stub loader)
   * @param addr - Address to read from
   * @param size - Number of bytes to read
   * @param onPacketReceived - Optional callback function called when packet is received
   * @returns Uint8Array containing the flash data
   */
  async readFlash(addr, size, onPacketReceived) {
    if (!this.IS_STUB) {
      throw new Error("Reading flash is only supported in stub mode. Please run runStub() first.");
    }
    await this.flushSerialBuffers();
    this.logger.log(`Reading ${size} bytes from flash at address 0x${addr.toString(16)}...`);
    const CHUNK_SIZE = 65536;
    let allData = new Uint8Array(0);
    let currentAddr = addr;
    let remainingSize = size;
    while (remainingSize > 0) {
      const chunkSize = Math.min(CHUNK_SIZE, remainingSize);
      let chunkSuccess = false;
      let retryCount = 0;
      const MAX_RETRIES = 5;
      let deepRecoveryAttempted = false;
      while (!chunkSuccess && retryCount <= MAX_RETRIES) {
        let resp = new Uint8Array(0);
        try {
          if (retryCount === 0) {
            this.logger.debug(`Reading chunk at 0x${currentAddr.toString(16)}, size: 0x${chunkSize.toString(16)}`);
          }
          const pkt = pack("<IIII", currentAddr, chunkSize, 4096, 1024);
          const [res] = await this.checkCommand(ESP_READ_FLASH, pkt);
          if (res != 0) {
            throw new Error("Failed to read memory: " + res);
          }
          while (resp.length < chunkSize) {
            let packet;
            try {
              packet = await this.readPacket(FLASH_READ_TIMEOUT);
            } catch (err2) {
              if (err2 instanceof SlipReadError) {
                this.logger.debug(`SLIP read error at ${resp.length} bytes: ${err2.message}`);
                try {
                  const abortFrame = [192, 192];
                  await this.writeToStream(abortFrame);
                  this.logger.debug(`Sent abort frame to stub`);
                  await sleep(50);
                } catch (abortErr) {
                  this.logger.debug(`Abort frame error: ${abortErr}`);
                }
                await this.drainInputBuffer(200);
                if (resp.length >= chunkSize) {
                  break;
                }
              }
              throw err2;
            }
            if (packet && packet.length > 0) {
              const packetData = new Uint8Array(packet);
              const newResp = new Uint8Array(resp.length + packetData.length);
              newResp.set(resp);
              newResp.set(packetData, resp.length);
              resp = newResp;
              const ackData = pack("<I", resp.length);
              const slipEncodedAck = slipEncode(ackData);
              await this.writeToStream(slipEncodedAck);
            }
          }
          const newAllData = new Uint8Array(allData.length + resp.length);
          newAllData.set(allData);
          newAllData.set(resp, allData.length);
          allData = newAllData;
          chunkSuccess = true;
        } catch (err2) {
          retryCount++;
          if (err2 instanceof SlipReadError) {
            if (retryCount <= MAX_RETRIES) {
              this.logger.log(`${err2.message} at 0x${currentAddr.toString(16)}. Draining buffer and retrying (attempt ${retryCount}/${MAX_RETRIES})...`);
              try {
                await this.drainInputBuffer(200);
                await this.flushSerialBuffers();
                await sleep(SYNC_TIMEOUT);
              } catch (drainErr) {
                this.logger.debug(`Buffer drain error: ${drainErr}`);
              }
            } else {
              if (!deepRecoveryAttempted) {
                deepRecoveryAttempted = true;
                this.logger.log(`All retries exhausted at 0x${currentAddr.toString(16)}. Attempting deep recovery (reconnect + reload stub)...`);
                try {
                  await this.reconnect();
                  this.logger.log("Deep recovery successful. Resuming read from current position...");
                  retryCount = 0;
                  continue;
                } catch (reconnectErr) {
                  throw new Error(`Failed to read chunk at 0x${currentAddr.toString(16)} after ${MAX_RETRIES} retries and deep recovery failed: ${reconnectErr}`);
                }
              } else {
                throw new Error(`Failed to read chunk at 0x${currentAddr.toString(16)} after ${MAX_RETRIES} retries and deep recovery attempt`);
              }
            }
          } else {
            throw err2;
          }
        }
      }
      if (onPacketReceived) {
        onPacketReceived(new Uint8Array(chunkSize), allData.length, size);
      }
      currentAddr += chunkSize;
      remainingSize -= chunkSize;
      this.logger.debug(`Total progress: 0x${allData.length.toString(16)} from 0x${size.toString(16)} bytes`);
    }
    this.logger.debug(`Successfully read ${allData.length} bytes from flash`);
    return allData;
  }
};
var EspStubLoader = class extends ESPLoader {
  constructor() {
    super(...arguments);
    this.IS_STUB = true;
  }
  /**
   * @name memBegin (592)
   * Start downloading an application image to RAM
   */
  async memBegin(size, _blocks, _blocksize, offset) {
    const stub = await getStubCode(this.chipFamily, this.chipRevision);
    if (stub === null) {
      return [0, []];
    }
    const load_start = offset;
    const load_end = offset + size;
    this.logger.debug(`Load range: ${toHex(load_start, 8)}-${toHex(load_end, 8)}`);
    this.logger.debug(`Stub data: ${toHex(stub.data_start, 8)}, len: ${stub.data.length}, text: ${toHex(stub.text_start, 8)}, len: ${stub.text.length}`);
    for (const [start, end] of [
      [stub.data_start, stub.data_start + stub.data.length],
      [stub.text_start, stub.text_start + stub.text.length]
    ]) {
      if (load_start < end && load_end > start) {
        throw new Error("Software loader is resident at " + toHex(start, 8) + "-" + toHex(end, 8) + ". Can't load binary at overlapping address range " + toHex(load_start, 8) + "-" + toHex(load_end, 8) + ". Try changing the binary loading address.");
      }
    }
    return [0, []];
  }
  /**
   * @name getEraseSize
   * depending on flash chip model the erase may take this long (maybe longer!)
   */
  async eraseFlash() {
    await this.checkCommand(ESP_ERASE_FLASH, [], 0, CHIP_ERASE_TIMEOUT);
  }
};

// temp_lib_v7_real/node_modules/tasmota-webserial-esptool/dist/index.js
var connect = async (logger) => {
  const port = await navigator.serial.requestPort();
  await port.open({ baudRate: ESP_ROM_BAUD });
  logger.log("Connected successfully.");
  return new ESPLoader(port, logger);
};
export {
  CHIP_FAMILY_ESP32,
  CHIP_FAMILY_ESP32C2,
  CHIP_FAMILY_ESP32C3,
  CHIP_FAMILY_ESP32C5,
  CHIP_FAMILY_ESP32C6,
  CHIP_FAMILY_ESP32C61,
  CHIP_FAMILY_ESP32H2,
  CHIP_FAMILY_ESP32H21,
  CHIP_FAMILY_ESP32H4,
  CHIP_FAMILY_ESP32P4,
  CHIP_FAMILY_ESP32S2,
  CHIP_FAMILY_ESP32S3,
  CHIP_FAMILY_ESP32S31,
  CHIP_FAMILY_ESP8266,
  ESPLoader,
  connect
};
/*! Bundled license information:

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>pyDirect Firmware Installer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Flash pyDirect MicroPython firmware to your ESP32 board with one click" />
  <style>
    :root {
      --primary: #6366f1;
      --primary-hover: #4f46e5;
      --bg: #0f172a;
      --surface: #1e293b;
      --text: #f8fafc;
      --text-muted: #94a3b8;
      --success: #10b981;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }
    
    .container {
      max-width: 600px;
      width: 100%;
    }
    
    .logo {
      font-size: 4rem;
      margin-bottom: 1rem;
      text-align: center;
    }
    
    h1 {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      background: linear-gradient(135deg, #6366f1, #a855f7);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-align: center;
    }
    
    .tagline {
      color: var(--text-muted);
      margin-bottom: 2rem;
      text-align: center;
    }

    /* Device info card */
    .device-info {
      background: var(--surface);
      border-radius: 0.75rem;
      padding: 1.5rem;
      margin-bottom: 2rem;
      display: none; /* Hidden until device detected */
    }

    .device-info.visible {
      display: block;
    }

    .device-info h2 {
      font-size: 1.25rem;
      margin-bottom: 1rem;
      color: var(--success);
    }

    .info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1rem;
    }

    .info-item {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .info-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .info-value {
      font-size: 1rem;
      color: var(--text);
      font-weight: 500;
    }

    /* Firmware selection */
    .firmware-info {
      background: rgba(99, 102, 241, 0.1);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 0.5rem;
      padding: 1rem;
      margin-bottom: 2rem;
      display: none;
    }

    .firmware-info.visible {
      display: block;
    }

    .firmware-info strong {
      color: var(--primary);
    }
    
    .chip-support {
      background: var(--surface);
      border-radius: 0.75rem;
      padding: 1rem;
      margin-bottom: 2rem;
    }
    
    .chip-support h3 {
      color: var(--text-muted);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 0.75rem;
    }
    
    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
    }
    
    .chip {
      background: rgba(99, 102, 241, 0.2);
      color: #a5b4fc;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
    }
    
    esp-web-install-button {
      display: block;
      margin: 2rem 0;
    }
    
    esp-web-install-button button {
      background: var(--primary);
      color: white;
      border: none;
      padding: 1rem 2rem;
      border-radius: 0.5rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      width: 100%;
    }
    
    esp-web-install-button button:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(99, 102, 241, 0.3);
    }
    
    .requirements {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.875rem;
    }
    
    .requirements a {
      color: #a5b4fc;
    }
    
    .footer {
      margin-top: 3rem;
      color: var(--text-muted);
      font-size: 0.75rem;
      text-align: center;
    }
    
    .footer a {
      color: #a5b4fc;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="logo">âš¡</div>
    <h1>pyDirect Firmware Installer</h1>
    <p class="tagline">Flash MicroPython + pyDirect modules to your ESP32 in one click</p>
    
    <!-- Device info (shown after detection) -->
    <div id="deviceInfo" class="device-info">
      <h2>âœ“ Device Detected</h2>
      <div class="info-grid">
        <div class="info-item">
          <span class="info-label">Chip</span>
          <span class="info-value" id="chipName">-</span>
        </div>
        <div class="info-item">
          <span class="info-label">Flash Size</span>
          <span class="info-value" id="flashSize">-</span>
        </div>
        <div class="info-item">
          <span class="info-label">PSRAM</span>
          <span class="info-value" id="psramSize">-</span>
        </div>
        <div class="info-item">
          <span class="info-label">MAC Address</span>
          <span class="info-value" id="macAddress">-</span>
        </div>
      </div>
    </div>

    <!-- Firmware selection info -->
    <div id="firmwareInfo" class="firmware-info">
      <strong>Selected firmware:</strong> <span id="selectedFirmware">-</span>
    </div>

    <div class="chip-support">
      <h3>Supported Chips</h3>
      <div class="chips">
        <span class="chip">ESP32-S3</span>
        <span class="chip">ESP32-P4</span>
        <span class="chip">ESP32</span>
        <span class="chip">ESP32-C3</span>
        <span class="chip">ESP32-C6</span>
      </div>
    </div>
    
    <!-- Custom Connect button for detection -->
    <button id="connectBtn" style="
      background: var(--primary);
      color: white;
      border: none;
      padding: 1rem 2rem;
      border-radius: 0.5rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-bottom: 1rem;
      transition: all 0.2s;
    " onmouseover="this.style.background='var(--primary-hover)'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 10px 25px rgba(99, 102, 241, 0.3)'" onmouseout="this.style.background='var(--primary)'; this.style.transform=''; this.style.boxShadow=''">
      Connect & Install pyDirect
    </button>

    <!-- Flash button, hidden until after detection -->
    <button id="flashBtn" style="
      background: var(--success);
      color: white;
      border: none;
      padding: 1rem 2rem;
      border-radius: 0.5rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-bottom: 1rem;
      transition: all 0.2s;
      display: none;
    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 10px 25px rgba(16, 185, 129, 0.3)'" onmouseout="this.style.transform=''; this.style.boxShadow=''">
      Flash Firmware Now
    </button>

    <!-- Debug: Skip to REPL WiFi Setup -->
    <button id="wifiSetupBtn" style="
      background: #8b5cf6;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-bottom: 1rem;
      transition: all 0.2s;
      display: none;
    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 10px 25px rgba(139, 92, 246, 0.3)'" onmouseout="this.style.transform=''; this.style.boxShadow=''">
      ðŸ“¡ Debug: WiFi Setup via REPL
    </button>

    <!-- Debug Log Window -->
    <div id="debugLog" style="
      display: none;
      background: #1e1e1e;
      border: 1px solid #333;
      border-radius: 0.5rem;
      padding: 1rem;
      margin-bottom: 1rem;
      max-height: 300px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      color: #00ff00;
    "></div>
    
    <!-- WiFi Network Selection Modal -->
    <div id="wifiModal" style="
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    ">
      <div style="
        background: var(--card-bg);
        border-radius: 1rem;
        padding: 1.5rem;
        max-width: 400px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
      ">
        <h3 style="margin: 0 0 1rem 0; color: white;">ðŸ“¡ Select WiFi Network</h3>
        <div id="wifiNetworkList"></div>
        <button id="wifiCancelBtn" style="
          width: 100%;
          margin-top: 1rem;
          padding: 0.75rem;
          background: #374151;
          color: white;
          border: none;
          border-radius: 0.5rem;
          cursor: pointer;
        ">Cancel</button>
      </div>
    </div>
    
    <p class="requirements">
      Requires Chrome, Edge, or Opera on desktop.<br>
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Serial_API#browser_compatibility" target="_blank">Browser compatibility</a>
    </p>
    
    <div class="footer">
      <p>
        <a href="https://github.com/jetpax/pyDirect" target="_blank">GitHub</a> â€¢
        <a href="https://github.com/jetpax/pyDirect/blob/master/README.md" target="_blank">Documentation</a>
      </p>
    </div>
  </div>

  <script type="module">
    import { ESPLoader } from './assets/libs/tasmota-esptool-v7-real.bundle.js';
    import forge from 'https://esm.sh/node-forge@1.3.1';

    // Generate self-signed certificate for device HTTPS
    function generateSelfSignedCert(hostname, validityYears = 10) {
      const keys = forge.pki.rsa.generateKeyPair(2048);
      const cert = forge.pki.createCertificate();
      
      cert.publicKey = keys.publicKey;
      cert.serialNumber = '01';
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + validityYears);
      
      const attrs = [{ name: 'commonName', value: hostname }];
      cert.setSubject(attrs);
      cert.setIssuer(attrs);
      
      // Add Subject Alternative Names for hostname.local and wildcard
      cert.setExtensions([
        { name: 'basicConstraints', cA: false },
        { name: 'keyUsage', digitalSignature: true, keyEncipherment: true },
        { name: 'extKeyUsage', serverAuth: true },
        {
          name: 'subjectAltName',
          altNames: [
            { type: 2, value: hostname },           // DNS
            { type: 2, value: `*.${hostname}` }     // Wildcard
          ]
        }
      ]);
      
      cert.sign(keys.privateKey, forge.md.sha256.create());
      
      return {
        certPem: forge.pki.certificateToPem(cert),
        keyPem: forge.pki.privateKeyToPem(keys.privateKey)
      };
    }

    const deviceInfo = document.getElementById('deviceInfo');
    const firmwareInfo = document.getElementById('firmwareInfo');
    const chipNameEl = document.getElementById('chipName');
    const flashSizeEl = document.getElementById('flashSize');
    const psramSizeEl = document.getElementById('psramSize');
    const macAddressEl = document.getElementById('macAddress');
    const selectedFirmwareEl = document.getElementById('selectedFirmware');
    const connectBtn = document.getElementById('connectBtn');
    const flashBtn = document.getElementById('flashBtn');
    const wifiSetupBtn = document.getElementById('wifiSetupBtn');

    // Global state
    let currentPort = null;
    let currentLoader = null;
    let detectedChipName = null;
    let detectedMacAddress = null;

    // Chip-specific eFuse base addresses (from tasmota-webserial-esptool v7.3.4)
    const EFUSE_BASES = {
      'ESP32-S3': 0x60007000,
      'ESP32-S2': 0x3f41A000,
      'ESP32-P4': 0x5012D000,
      'ESP32': 0x3ff5A000
    };

    // Helper function to read eFuse register
    async function readEfuseRegister(loader, address) {
      try {
        return await loader.readRegister(address);
      } catch (e) {
        console.warn(`Failed to read eFuse register at ${address.toString(16)}:`, e);
        return null;
      }
    }

    // Detect PSRAM for ESP32-S3
    async function detectS3Psram(loader) {
      const EFUSE_BASE = EFUSE_BASES['ESP32-S3'];
      const reg = await readEfuseRegister(loader, EFUSE_BASE + 0x044 + 4 * 4);
      
      if (reg === null) return 'Unknown';
      
      const psramCap = (reg >> 3) & 0x03;
      const psramVendor = (reg >> 7) & 0x03;
      
      const psramSizes = {
        0: null,
        1: '8MB',
        2: '2MB',
        3: '8MB or more'
      };
      
      const psramVendors = {
        1: 'AP_3v3',
        2: 'AP_1v8'
      };
      
      const size = psramSizes[psramCap];
      if (!size) return 'None';
      
      const vendor = psramVendors[psramVendor];
      return vendor ? `${size} (${vendor})` : size;
    }

    // Detect PSRAM for ESP32-S2
    async function detectS2Psram(loader) {
      const EFUSE_BASE = EFUSE_BASES['ESP32-S2'];
      const EFUSE_BLOCK1_ADDR = EFUSE_BASE + 0x44;
      const reg = await readEfuseRegister(loader, EFUSE_BLOCK1_ADDR + 4 * 3);
      
      if (reg === null) return 'Unknown';
      
      const psramCap = (reg >> 28) & 0x0f;
      
      const psramSizes = {
        0: null,
        1: '2MB'
      };
      
      const size = psramSizes[psramCap];
      return size || 'None';
    }

    // Detect PSRAM based on chip type
    async function detectPsram(loader, chipName) {
      if (chipName.includes('ESP32-S3')) {
        return await detectS3Psram(loader);
      } else if (chipName.includes('ESP32-S2')) {
        return await detectS2Psram(loader);
      } else {
        // For other chips, try feature detection
        try {
          if (loader.chip.getChipFeatures) {
            const features = await loader.chip.getChipFeatures(loader);
            console.log("Chip Features:", features);
            
            // Check for PSRAM in features
            const psramFeature = features.find(f => f.includes('PSRAM'));
            if (psramFeature) {
              return psramFeature.replace('Embedded ', '');
            }
          }
        } catch (e) {
          console.warn("Feature detection failed:", e);
        }
        return 'None';
      }
    }

    // Perform hardware detection
    async function detectHardware(port) {
      const logger = {
        log: (msg) => console.log(msg),
        debug: (msg) => console.debug(msg),
        error: (msg) => console.error(msg)
      };

      const loader = new ESPLoader(port, logger);

      // Connect and detect chip (ROM mode)
      await loader.initialize();
      const chipName = loader.chipName || 'Unknown';
      console.log("Connected to chip:", chipName);

      // MAC Address
      const macAddr = loader.macAddr();
      const macAddress = Array.isArray(macAddr) && macAddr.length >= 6
        ? macAddr.slice(0, 6).map(b => b.toString(16).padStart(2, '0')).join(':')
        : 'Unknown';
      
      // Run the stub loader for advanced detection
      let flashSizeMB = 'Unknown';
      let psramInfo = 'Unknown';

      try {
          console.log("Running stub...");
          const stubLoader = await loader.runStub();
          
          // Detect flash size using the stub
          await stubLoader.detectFlashSize();
          flashSizeMB = stubLoader.flashSize || 'Unknown';
          console.log("Flash size detected:", flashSizeMB);

          // Detect PSRAM using chip-specific eFuse reads
          psramInfo = await detectPsram(stubLoader, chipName);
          console.log("PSRAM detected:", psramInfo);
          
          // Keep the stub loader for flashing
          currentLoader = stubLoader;
          
      } catch (e) {
          console.warn("Stub/Feature detection failed:", e);
          flashSizeMB = 'Detection Failed';
          psramInfo = 'Detection Failed';
          currentLoader = loader;
      }

      // Update UI
      chipNameEl.textContent = chipName || 'Unknown';
      flashSizeEl.textContent = flashSizeMB;
      psramSizeEl.textContent = psramInfo;
      macAddressEl.textContent = macAddress;

      // Show device info card
      deviceInfo.classList.add('visible');

      // Determine and show selected firmware
      let firmware = 'Unknown';
      if (chipName && chipName.includes('ESP32-S3')) {
        firmware = 'pyDirect for ESP32-S3 (8MB Flash, 2MB PSRAM)';
      } else if (chipName && chipName.includes('ESP32-P4')) {
        firmware = 'pyDirect for ESP32-P4 (16MB Flash)';
      }
      selectedFirmwareEl.textContent = firmware;
      firmwareInfo.classList.add('visible');

      return { chipName, flashSizeMB, psramInfo, macAddress };
    }

    // Wire up the connect button
    connectBtn.addEventListener('click', async () => {
      try {
        connectBtn.textContent = 'Connecting...';
        connectBtn.disabled = true;

        // Request serial port
        currentPort = await navigator.serial.requestPort({});
        await currentPort.open({ baudRate: 115200 });

        // Perform detection
        const result = await detectHardware(currentPort);
        detectedChipName = result.chipName;
        detectedMacAddress = result.macAddress;

        // Update button and show flash button
        connectBtn.textContent = 'âœ“ Connected';
        connectBtn.style.background = 'var(--success)';
        
        // Show the flash button and debug button (port stays open)
        flashBtn.style.display = 'block';
        wifiSetupBtn.style.display = 'block';

      } catch (error) {
        console.error('Detection error:', error);
        connectBtn.textContent = 'Connection Failed - Try Again';
        connectBtn.disabled = false;
        connectBtn.style.background = 'var(--primary)';
        
        // Clean up on error
        if (currentPort) {
          try {
            await currentPort.close();
          } catch (e) {}
          currentPort = null;
        }
        currentLoader = null;
        
        alert('Failed to connect: ' + error.message);
      }
    });

    // REPL Communication Helpers
    async function sendCtrlC(port) {
      const writer = port.writable.getWriter();
      await writer.write(new Uint8Array([0x03])); // Ctrl+C
      writer.releaseLock();
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    async function sendREPLCommand(port, pythonCode, timeoutMs = 15000, enterRawMode = true) {
      const writer = port.writable.getWriter();
      
      try {
        // Clean the Python code - remove common leading whitespace but preserve relative indentation
        const lines = pythonCode.split('\n').filter(line => line.trim().length > 0);
        const minIndent = Math.min(...lines.map(line => {
          const match = line.match(/^(\s*)/);
          return match ? match[1].length : 0;
        }));
        const cleanCode = lines.map(line => line.slice(minIndent)).join('\n');
        
        // Only enter raw REPL if requested (first command)
        if (enterRawMode) {
          await writer.write(new Uint8Array([0x01])); // Ctrl+A - enter raw REPL
          await new Promise(r => setTimeout(r, 100));
        }
        
        // Send code and execute with Ctrl+D
        await writer.write(new TextEncoder().encode(cleanCode));
        await new Promise(r => setTimeout(r, 50));
        await writer.write(new Uint8Array([0x04])); // Ctrl+D - execute
        writer.releaseLock();
        
        // Now read the response
        const reader = port.readable.getReader();
        let output = '';
        const decoder = new TextDecoder();
        const startTime = Date.now();
        
        // Read until we see the pattern: ...OK...output...>
        // We need to see "OK" (code accepted) followed eventually by ">" (execution done)
        while (Date.now() - startTime < timeoutMs) {
          const { value, done } = await reader.read();
          
          if (done) break;
          if (value) {
            output += decoder.decode(value);

            
            if (output.includes('OK') && output.endsWith('>')) {
              break;
            }
          }
        }

        
        // Stay in raw REPL mode - don't exit (no Ctrl+B)
        // This avoids the repeated "MicroPython..." banner
        
        reader.releaseLock();
        return output;
      } catch (e) {
        try { writer.releaseLock(); } catch {}
        throw e;
      }
    }

    // Upload certificates to device filesystem via REPL
    async function uploadCertsToDevice(port, certPem, keyPem, addDebugLog) {
      addDebugLog('> Creating /certs directory...');
      
      // Create /certs directory (ignore error if exists)
      await sendREPLCommand(port, `
import os
try:
    os.mkdir('/certs')
except OSError:
    pass
print('DIR_OK')
`, 3000, false);

      addDebugLog('> Writing certificate...');
      
      // Write cert file using base64 to handle special characters
      const certB64 = btoa(certPem);
      await sendREPLCommand(port, `
import binascii
with open('/certs/servercert.pem', 'wb') as f:
    f.write(binascii.a2b_base64('${certB64}'))
print('CERT_OK')
`, 5000, false);

      addDebugLog('> Writing private key...');
      
      // Write key file
      const keyB64 = btoa(keyPem);
      await sendREPLCommand(port, `
with open('/certs/prvtkey.pem', 'wb') as f:
    f.write(binascii.a2b_base64('${keyB64}'))
print('KEY_OK')
`, 5000, false);

      addDebugLog('> Certificates installed!');
    }

    // Wire up the REPL WiFi setup button
    wifiSetupBtn.addEventListener('click', async () => {
      if (!currentPort || !currentLoader) {
        alert('No device connected. Please connect first.');
        return;
      }

      try {
        wifiSetupBtn.textContent = 'Rebooting to MicroPython...';
        wifiSetupBtn.disabled = true;

        // Show debug log
        const debugLog = document.getElementById('debugLog');
        debugLog.style.display = 'block';
        debugLog.innerHTML = '';
        
        function addDebugLog(msg) {
          const line = document.createElement('div');
          line.textContent = msg;
          debugLog.appendChild(line);
          debugLog.scrollTop = debugLog.scrollHeight;
        }

        addDebugLog('> Switching to 115200 and resetting...');
        
        // Disconnect loader (don't need it anymore)
        await currentLoader.disconnect();
        currentLoader = null;
        
        // Close and reopen at MicroPython baud rate FIRST
        await currentPort.close();
        await new Promise(resolve => setTimeout(resolve, 100));
        await currentPort.open({ baudRate: 115200 });
        
        // Now send reset signals (correct sequence for normal boot, not download mode)
        // DTR=false keeps GPIO0 high (normal boot mode)
        // Pulse RTS to trigger reset
        await currentPort.setSignals({ dataTerminalReady: false, requestToSend: false });
        await new Promise(resolve => setTimeout(resolve, 50));
        await currentPort.setSignals({ dataTerminalReady: false, requestToSend: true }); // Assert reset
        await new Promise(resolve => setTimeout(resolve, 100));
        await currentPort.setSignals({ dataTerminalReady: false, requestToSend: false }); // Release reset
        
        addDebugLog('> Waiting for pyDirect banner...');
        
        // Watch for the pyDirect banner
        const bootReader = currentPort.readable.getReader();
        const bootDecoder = new TextDecoder();
        let bootOutput = '';
        const bootStart = Date.now();
        let bannerFound = false;
        
        while (Date.now() - bootStart < 8000) { // 8 second max wait
          const { value, done } = await bootReader.read();
          if (done) break;
          if (value) {
            bootOutput += bootDecoder.decode(value);
            // Look for the pyDirect banner 
            if (bootOutput.includes('System booting...')) {
              addDebugLog('> System booting... detected!');
              bannerFound = true;
              break;
            }
          }
        }
        bootReader.releaseLock();
        
        // Send Ctrl+C IMMEDIATELY after releasing reader
        if (bannerFound) {
          addDebugLog('> Sending interrupt...');
          const writer = currentPort.writable.getWriter();
          await writer.write(new Uint8Array([0x03])); // Ctrl+C
          await new Promise(r => setTimeout(r, 50));
          await writer.write(new Uint8Array([0x03])); // Ctrl+C again
          writer.releaseLock();
        }
        
        // Brief pause for interrupt to take effect
        await new Promise(resolve => setTimeout(resolve, 200));
        
        addDebugLog('> Scanning for WiFi networks...');
        wifiSetupBtn.textContent = 'Scanning networks...';
        
        // Scan networks via REPL - output as JSON for easy parsing
        const scanOutput = await sendREPLCommand(currentPort, `
import network  # MicroPython built-in (has WLAN)
import json
wlan = network.WLAN(network.STA_IF)
wlan.active(True)
raw = wlan.scan()
# Deduplicate by SSID, keeping strongest signal
nets = {}
for ssid, bssid, channel, rssi, authmode, hidden in raw:
    s = ssid.decode()
    if s and (s not in nets or rssi > nets[s][0]):
        nets[s] = (rssi, authmode)
# Convert to sorted list (by rssi descending)
result = [{"ssid": k, "rssi": v[0], "sec": v[1] != 0} for k, v in nets.items()]
result.sort(key=lambda x: x["rssi"], reverse=True)
print("JSON:" + json.dumps(result))
`);
        

        
        // Extract JSON from output
        const jsonMatch = scanOutput.match(/JSON:(\[.*\])/);
        if (!jsonMatch) {
          throw new Error('Failed to parse network scan - no JSON found');
        }
        
        let networks;
        try {
          networks = JSON.parse(jsonMatch[1]);
        } catch (e) {
          throw new Error('Failed to parse network JSON: ' + e.message);
        }
        
        if (networks.length === 0) {
          throw new Error('No WiFi networks found');
        }
        
        addDebugLog(`> Found ${networks.length} networks`);
        
        // Network selection and connection loop (allows retry on failure)
        let connected = false;
        let deviceIP = null;
        let savedHostname = null;
        
        // Helper to show network selection modal
        function showNetworkModal(networks) {
          return new Promise((resolve, reject) => {
            const modal = document.getElementById('wifiModal');
            const list = document.getElementById('wifiNetworkList');
            const cancelBtn = document.getElementById('wifiCancelBtn');
            
            // Build network list HTML
            list.innerHTML = networks.map((n, i) => {
              const bars = n.rssi >= -50 ? 'â–‚â–„â–†â–ˆ' : n.rssi >= -60 ? 'â–‚â–„â–†_' : n.rssi >= -70 ? 'â–‚â–„__' : n.rssi >= -80 ? 'â–‚___' : 'â–‚___';
              return `<button class="wifi-item" data-index="${i}" style="
                width: 100%;
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0.75rem 1rem;
                margin-bottom: 0.5rem;
                background: #374151;
                color: white;
                border: 2px solid transparent;
                border-radius: 0.5rem;
                cursor: pointer;
                transition: all 0.2s;
              " onmouseover="this.style.borderColor='var(--primary)'" onmouseout="this.style.borderColor='transparent'">
                <span style="font-weight: 500;">${n.ssid}</span>
                <span style="font-family: monospace; opacity: 0.7;">${n.sec ? 'ðŸ”’ ' : ''}${bars}</span>
              </button>`;
            }).join('');
            
            // Show modal
            modal.style.display = 'flex';
            
            // Handle network click
            const handleClick = (e) => {
              const btn = e.target.closest('.wifi-item');
              if (btn) {
                const index = parseInt(btn.dataset.index);
                cleanup();
                resolve(index);
              }
            };
            
            // Handle cancel
            const handleCancel = () => {
              cleanup();
              reject(new Error('Setup cancelled'));
            };
            
            const cleanup = () => {
              modal.style.display = 'none';
              list.removeEventListener('click', handleClick);
              cancelBtn.removeEventListener('click', handleCancel);
            };
            
            list.addEventListener('click', handleClick);
            cancelBtn.addEventListener('click', handleCancel);
          });
        }
        
        while (!connected) {
          // Show network selection modal
          const selectedIndex = await showNetworkModal(networks);
          
          const selectedNetwork = networks[selectedIndex];
          const password = prompt(`Enter password for "${selectedNetwork.ssid}":`);
          
          if (password === null) {
            // User cancelled password - let them reselect network
            continue;
          }
          
          addDebugLog(`> Connecting to "${selectedNetwork.ssid}"...`);
          wifiSetupBtn.textContent = 'Connecting to WiFi...';
          
          // Connect to WiFi via REPL (already in raw mode from scan)
          const connectOutput = await sendREPLCommand(currentPort, `
import time
try:
    wlan.disconnect()
except:
    pass
time.sleep(0.3)
wlan.connect('${selectedNetwork.ssid}', '${password}')
for i in range(20):
    if wlan.isconnected():
        ip = wlan.ifconfig()[0]
        print(f"CONNECTED:{ip}")
        break
    time.sleep(0.5)
else:
    print("FAILED:timeout")
`, 15000, false);  // Already in raw mode
          

          
          // Parse connection result
          const connMatch = connectOutput.match(/CONNECTED:(\d+\.\d+\.\d+\.\d+)/);
          if (connMatch) {
            deviceIP = connMatch[1];
            connected = true;
            addDebugLog(`> Connected! IP: ${deviceIP}`);
            
            // Save WiFi credentials and hostname to settings
            addDebugLog(`> Saving settings...`);
            
            // Compute hostname from ESPLoader MAC (base MAC - consistent across interfaces)
            const macSuffix = detectedMacAddress 
              ? detectedMacAddress.replace(/:/g, '').slice(-4).toLowerCase()
              : 'xxxx';
            const hostname = `pydirect-${macSuffix}`;
            
            await sendREPLCommand(currentPort, `
from lib.sys import settings
settings.set("wifi.ssid", "${selectedNetwork.ssid}")
settings.set("wifi.password", "${password}")
settings.set("server.https_enabled", True)
settings.set("device.hostname", "${hostname}")
settings.save()
print("SETTINGS_OK")
`, 5000, false);
            addDebugLog(`> Settings saved (hostname: ${hostname})`);
            
            // Store for cert generation
            savedHostname = hostname;
          } else {
            addDebugLog('> Connection failed');
            const retry = confirm('WiFi connection failed. Wrong password?\n\nClick OK to try again, or Cancel to abort.');
            if (!retry) {
              throw new Error('Connection cancelled');
            }
            wifiSetupBtn.textContent = 'Retrying...';
          }
        }
        
        // Generate and install HTTPS certificate
        wifiSetupBtn.textContent = 'Generating certificate...';
        addDebugLog('> Generating HTTPS certificate...');
        
        // Use hostname saved to settings (from ESPLoader base MAC)
        const certHostname = savedHostname + '.local';
        addDebugLog(`> Hostname: ${certHostname}`);
        
        // Generate self-signed certificate
        const { certPem, keyPem } = generateSelfSignedCert(certHostname);
        addDebugLog(`> Certificate generated (${certPem.length} bytes)`);
        
        // Upload to device
        wifiSetupBtn.textContent = 'Installing certificate...';
        await uploadCertsToDevice(currentPort, certPem, keyPem, addDebugLog);
        
        // === Set setup mode flag before reset ===
        wifiSetupBtn.textContent = 'Configuring setup mode...';
        addDebugLog('> Setting setup mode flag...');
        await sendREPLCommand(currentPort, `
from lib.sys import settings
settings.set("setup_mode", True)
settings.save()
print("SETUP_MODE_SET")
`, 5000, false);
        
        // Hard reset to apply settings and enter setup mode
        wifiSetupBtn.textContent = 'Restarting device...';
        addDebugLog('> Resetting device...');
        await sendREPLCommand(currentPort, 'import machine; machine.reset()', 1000, false);
        
        // Close port and redirect to device setup page
        const setupUrl = `https://${certHostname}/setup`;
        addDebugLog(`> Device will boot into setup mode`);
        addDebugLog(`> Redirecting to ${setupUrl} in 5 seconds...`);
        
        await currentPort.close();
        currentPort = null;
        
        // Brief pause for device to boot, then redirect
        wifiSetupBtn.textContent = 'âœ“ Redirecting to device setup...';
        wifiSetupBtn.style.background = '#10b981';
        
        setTimeout(() => {
          window.location.href = setupUrl;
        }, 5000); // 5 seconds for device to boot and start HTTPS
        
        // Note: The UI reset below won't run since we're redirecting,
        // but keeping it for cases where redirect might fail
        setTimeout(() => {
          connectBtn.textContent = 'Connect & Install pyDirect';
          connectBtn.disabled = false;
          connectBtn.style.background = 'var(--primary)';
          flashBtn.style.display = 'none';
          wifiSetupBtn.style.display = 'none';
          wifiSetupBtn.style.background = '#8b5cf6';
          wifiSetupBtn.textContent = 'ðŸ“¡ WiFi Setup';
          wifiSetupBtn.disabled = false;
        }, 10000);


      } catch (error) {
        console.error('WiFi setup error:', error);
        wifiSetupBtn.textContent = 'ðŸ“¡ Debug: WiFi Setup via REPL';
        wifiSetupBtn.disabled = false;
        alert('WiFi setup failed: ' + error.message);
        
        // Clean up on error
        try {
          if (currentPort) await currentPort.close();
        } catch (e) {}
        currentPort = null;
        currentLoader = null;
      }
    });
    // Wire up the flash button
    flashBtn.addEventListener('click', async () => {
      if (!currentPort || !currentLoader) {
        alert('No device connected. Please connect first.');
        return;
      }

      try {
        flashBtn.textContent = 'Loading firmware...';
        flashBtn.disabled = true;

        // Load the manifest to get firmware files
        const manifestResp = await fetch('./manifest.json');
        const manifest = await manifestResp.json();
        
        // Find the right build for the detected chip
        let selectedBuild = null;
        for (const build of manifest.builds) {
          if (detectedChipName && detectedChipName.includes(build.chipFamily)) {
            selectedBuild = build;
            break;
          }
        }

        if (!selectedBuild) {
          throw new Error(`No firmware found for ${detectedChipName}`);
        }

        console.log('Selected build:', selectedBuild);

        // Download and flash each part
        for (let i = 0; i < selectedBuild.parts.length; i++) {
          const part = selectedBuild.parts[i];
          console.log(`Starting flash of part ${i + 1}/${selectedBuild.parts.length} at offset ${part.offset}`);
          
          flashBtn.textContent = `Downloading ${i + 1}/${selectedBuild.parts.length}...`;
          const resp = await fetch(part.path);
          const data = new Uint8Array(await resp.arrayBuffer());
          console.log(`Downloaded ${data.length} bytes`);
          
          // Flash with progress callback (matching ESPConnect pattern)
          console.log('About to call flashData...');
          let progressPercent = 0;
          try {
            await currentLoader.flashData(
              data.buffer,  // Use .buffer property like ESPConnect
              (bytesWritten, totalBytes) => {
                progressPercent = Math.floor((bytesWritten / totalBytes) * 100);
                flashBtn.textContent = `Flashing ${i + 1}/${selectedBuild.parts.length}: ${progressPercent}%`;
              },
              part.offset,
              true  // compress = true (ESPConnect uses compression)
            );
            console.log(`flashData completed successfully - ${progressPercent}%`);
            flashBtn.textContent = `âœ“ Flashed ${i + 1}/${selectedBuild.parts.length}`;
          } catch (flashError) {
            // Check if this is the finalization timeout (device already rebooted)
            const errorMsg = flashError?.message || String(flashError);
            if (errorMsg.includes('Timed out waiting for packet header') && progressPercent === 100) {
              // Flash completed successfully, device rebooted before finalization response
              console.log('Flash completed successfully (device rebooted)');
              flashBtn.textContent = `âœ“ Flashed ${i + 1}/${selectedBuild.parts.length}`;
            } else {
              console.error('flashData threw an error:', flashError);
              throw flashError;
            }
          }
          console.log(`Completed flashing part ${i + 1}`);
        }

        flashBtn.textContent = 'âœ“ Flash Complete!';
        flashBtn.style.background = '#10b981';
        
        alert('Firmware flashed successfully! Your device will now restart.');

        // Clean up
        try {
          await currentPort.close();
        } catch (e) {}
        currentPort = null;
        currentLoader = null;

      } catch (error) {
        console.error('Flash error:', error);
        flashBtn.textContent = 'Flash Failed - Reconnect to Retry';
        flashBtn.disabled = false;
        alert('Failed to flash firmware: ' + error.message);
        
        // Clean up on error
        try {
          if (currentPort) await currentPort.close();
        } catch (e) {}
        currentPort = null;
        currentLoader = null;
        
        // Reset UI
        connectBtn.textContent = 'Connect & Install pyDirect';
        connectBtn.disabled = false;
        connectBtn.style.background = 'var(--primary)';
        flashBtn.style.display = 'none';
      }
    });
  </script>
</body>
</html>

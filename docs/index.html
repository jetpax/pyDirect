<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>pyDirect Firmware Installer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Flash pyDirect MicroPython firmware to your ESP32 board with one click" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@tabler/icons-webfont@latest/dist/tabler-icons.min.css" />
  <style>
    :root {
      /* Professional understated palette */
      --primary: #5B8DEF;
      --primary-hover: #4A7DE0;
      --primary-glow: rgba(91, 141, 239, 0.15);
      --accent: #7C8DB5;
      --success: #4CAF7C;
      --warning: #E0A458;
      --error: #D66B6B;
      
      /* Backgrounds */
      --bg: #0D1117;
      --bg-gradient: linear-gradient(135deg, #0D1117 0%, #161B22 100%);
      --surface: #161B22;
      --surface-hover: #1C2128;
      --surface-elevated: #21262D;
      --glass: rgba(255, 255, 255, 0.03);
      --glass-border: rgba(255, 255, 255, 0.08);
      
      /* Text */
      --text: #E6EDF3;
      --text-secondary: #8B949E;
      --text-muted: #6E7681;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-gradient);
      color: var(--text);
      min-height: 100vh;
      padding: 1.5rem;
    }
    
    .app-container {
      max-width: 640px;
      margin: 0 auto;
    }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 2rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--glass-border);
    }
    
    .header-icon {
      font-size: 1.5rem;
    }
    
    .header h1 {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text);
    }
    
    .header-version {
      margin-left: auto;
      font-size: 0.75rem;
      color: var(--text-muted);
      background: var(--surface);
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
    }

    /* Views */
    .view { display: none; }
    .view.active { display: block; animation: fadeIn 0.2s ease; }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Welcome Section */
    .welcome {
      text-align: center;
      margin-bottom: 1.5rem;
    }
    
    .welcome h2 {
      font-size: 1.5rem;
      font-weight: 500;
      margin-bottom: 0.5rem;
    }
    
    .welcome p {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    /* Scenario Cards */
    .scenario-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }
    
    .scenario-card {
      background: var(--glass);
      border: 1px solid var(--glass-border);
      border-radius: 0.75rem;
      padding: 1.25rem;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: left;
    }
    
    .scenario-card:hover {
      background: var(--surface-hover);
      border-color: var(--primary);
      transform: translateY(-2px);
    }
    
    .scenario-icon {
      font-size: 1.5rem;
      margin-bottom: 0.75rem;
      color: var(--primary);
    }
    
    .scenario-icon i {
      font-size: 1.75rem;
    }
    
    .scenario-card h3 {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.35rem;
    }
    
    .scenario-card p {
      font-size: 0.75rem;
      color: var(--text-muted);
      line-height: 1.4;
    }

    /* Hint Box */
    .hint-box {
      background: var(--surface);
      border-radius: 0.5rem;
      padding: 0.875rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.625rem;
      margin-bottom: 1rem;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    /* Terminal */
    .terminal-wrapper {
      border: 1px solid var(--glass-border);
      border-radius: 0.5rem;
      overflow: hidden;
      margin-bottom: 1rem;
    }
    
    .terminal-header {
      background: var(--surface);
      padding: 0.5rem 0.75rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
    }
    
    .terminal-header span {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .terminal-toggle {
      font-size: 0.7rem;
      color: var(--text-muted);
      transition: transform 0.2s;
    }
    
    .terminal-wrapper.collapsed .terminal-toggle {
      transform: rotate(-90deg);
    }
    
    .terminal-content {
      background: #0A0D10;
      padding: 0.75rem;
      max-height: 180px;
      overflow-y: auto;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 0.8rem;
      color: #7EE787;
      transition: max-height 0.2s ease;
    }
    
    .terminal-wrapper.collapsed .terminal-content {
      max-height: 0;
      padding: 0 0.75rem;
    }

    /* Buttons */
    .btn {
      display: block;
      width: 100%;
      padding: 0.875rem 1.5rem;
      border: none;
      border-radius: 0.5rem;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 0.5rem;
    }
    
    .btn-primary {
      background: var(--primary);
      color: white;
    }
    
    .btn-primary:hover:not(:disabled) {
      background: var(--primary-hover);
      box-shadow: 0 4px 12px var(--primary-glow);
    }
    
    .btn-success {
      background: var(--success);
      color: white;
    }
    
    .btn-secondary {
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--glass-border);
    }
    
    .btn-secondary:hover {
      background: var(--surface-hover);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .btn-back {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 0.8rem;
      cursor: pointer;
      padding: 0.5rem;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }
    
    .btn-back:hover {
      color: var(--text);
    }

    /* Device Info Card */
    .device-card {
      background: var(--surface);
      border: 1px solid var(--glass-border);
      border-radius: 0.75rem;
      padding: 1.25rem;
      margin-bottom: 1rem;
    }
    
    .device-info-compact {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1rem;
      background: var(--surface-elevated);
      border-radius: 0.5rem;
      margin-bottom: 1.25rem;
      font-size: 0.85rem;
    }
    
    .device-info-compact i {
      color: var(--primary);
    }
    
    .device-card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1rem;
    }
    
    .device-card h3 {
      font-size: 0.9rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .status-badge {
      font-size: 0.7rem;
      padding: 0.2rem 0.5rem;
      border-radius: 1rem;
      background: var(--success);
      color: white;
    }
    
    .info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.875rem;
    }
    
    .info-item label {
      display: block;
      font-size: 0.65rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.2rem;
    }
    
    .info-item span {
      font-size: 0.85rem;
      color: var(--text);
    }

    /* Credential Display */
    .credential-box {
      background: var(--surface-elevated);
      border-radius: 0.5rem;
      padding: 1rem;
      margin-bottom: 0.75rem;
    }
    
    .credential-box label {
      display: block;
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 0.35rem;
    }
    
    .credential-box .value-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    
    .credential-box .value {
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 1rem;
      color: var(--primary);
      word-break: break-all;
    }
    
    .btn-copy {
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 0.25rem;
      transition: all 0.15s;
      flex-shrink: 0;
    }
    
    .btn-copy:hover {
      color: var(--primary);
      background: var(--glass);
    }
    
    .btn-copy i {
      font-size: 1.1rem;
    }

    /* Product Select */
    .form-group {
      margin-bottom: 1rem;
    }
    
    .form-group label {
      display: block;
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-bottom: 0.35rem;
    }
    
    .form-group select {
      width: 100%;
      padding: 0.75rem;
      border-radius: 0.5rem;
      border: 1px solid var(--glass-border);
      background: var(--surface);
      color: var(--text);
      font-size: 0.9rem;
    }

    /* Modals */
    .modal-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.75);
      z-index: 100;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }
    
    .modal-overlay.active {
      display: flex;
    }
    
    .modal {
      background: var(--surface);
      border-radius: 0.75rem;
      padding: 1.5rem;
      max-width: 400px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .modal h3 {
      font-size: 1.1rem;
      margin-bottom: 1rem;
    }

    /* WiFi List */
    .wifi-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem;
      background: var(--surface-elevated);
      border: 1px solid transparent;
      border-radius: 0.5rem;
      margin-bottom: 0.5rem;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .wifi-item:hover {
      border-color: var(--primary);
    }
    
    .wifi-name {
      font-weight: 500;
    }
    
    .wifi-signal {
      font-family: monospace;
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    /* Footer */
    .footer {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.75rem;
      margin-top: 1.5rem;
    }
    
    .footer a {
      color: var(--text-secondary);
      text-decoration: none;
    }
    
    .footer a:hover {
      color: var(--primary);
    }

    /* Progress Steps */
    .progress-steps {
      display: flex;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }
    
    .progress-step {
      width: 2rem;
      height: 3px;
      background: var(--glass-border);
      border-radius: 2px;
      transition: background 0.2s;
    }
    
    .progress-step.active {
      background: var(--primary);
    }
    
    .progress-step.complete {
      background: var(--success);
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Header -->
    <div class="header">
      <span class="header-icon"><i class="ti ti-bolt"></i></span>
      <h1>pyDirect Setup</h1>
      <span class="header-version">v2.0</span>
    </div>

    <!-- View: Landing / Scenario Selection -->
    <div id="viewLanding" class="view active">
      <div class="welcome">
        <h2>Welcome to pyDirect</h2>
        <p id="welcomeSubtitle">Connect your device to get started</p>
      </div>

      <!-- Step 1: Connect -->
      <div id="landingConnect">
        <button class="btn btn-primary" onclick="connectAndDetect()" id="landingConnectBtn">
          <i class="ti ti-usb"></i> Connect Device
        </button>
        
        <div class="hint-box" style="margin-top: 1.5rem;">
          <i class="ti ti-bulb"></i>
          <span>Plug in your ESP32 via USB and click Connect.</span>
        </div>
      </div>

      <!-- Step 2: Show scenarios after connected -->
      <div id="landingScenarios" style="display: none;">
        <div class="device-info-compact" id="connectedDeviceInfo">
          <i class="ti ti-cpu"></i>
          <span id="connectedChipName">-</span>
          <span class="status-badge" id="deviceStatus">Connected</span>
        </div>
        
        <div class="scenario-grid">
          <div class="scenario-card" id="scenarioNew" onclick="selectScenario('new')">
            <div class="scenario-icon"><i class="ti ti-cpu"></i></div>
            <h3>New Device</h3>
            <p>Flash fresh firmware onto a blank ESP32</p>
          </div>
          <div class="scenario-card" id="scenarioForgot" onclick="selectScenario('forgot')">
            <div class="scenario-icon"><i class="ti ti-key"></i></div>
            <h3>Forgot Credentials</h3>
            <p>View saved hostname and password</p>
          </div>
          <div class="scenario-card" id="scenarioWifi" onclick="selectScenario('wifi')">
            <div class="scenario-icon"><i class="ti ti-wifi"></i></div>
            <h3>Change WiFi</h3>
            <p>Update network settings on existing device</p>
          </div>
          <div class="scenario-card" id="scenarioRebless" onclick="selectScenario('rebless')">
            <div class="scenario-icon"><i class="ti ti-refresh"></i></div>
            <h3>Re-provision</h3>
            <p>Fresh start with new certificates</p>
          </div>
        </div>
        
        <button class="btn btn-secondary" onclick="disconnectDevice()" style="margin-top: 1rem;">
          <i class="ti ti-unlink"></i> Disconnect
        </button>
      </div>
    </div>

    <!-- View: New Device Flow -->
    <div id="viewNewDevice" class="view">
      <button class="btn-back" onclick="goBackToScenarios()">← Back</button>
      
      <div class="progress-steps">
        <div class="progress-step" id="step1"></div>
        <div class="progress-step" id="step2"></div>
        <div class="progress-step" id="step3"></div>
        <div class="progress-step" id="step4"></div>
      </div>

      <!-- Step 1: Connect -->
      <div id="newStep1">
        <h2 style="font-size: 1.1rem; margin-bottom: 0.5rem;">Step 1: Connect Device</h2>
        <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1.5rem;">
          Connect your ESP32 via USB. You'll be prompted to select the serial port.
        </p>
        <button id="connectBtn" class="btn btn-primary" onclick="connectDevice()">
          Connect to ESP32
        </button>
      </div>

      <!-- Step 2: Device Detected + Flash -->
      <div id="newStep2" style="display: none;">
        <div class="device-card" id="deviceInfo">
          <div class="device-card-header">
            <h3>✓ Device Detected</h3>
            <span class="status-badge">● Connected</span>
          </div>
          <div class="info-grid">
            <div class="info-item">
              <label>Chip</label>
              <span id="chipName">-</span>
            </div>
            <div class="info-item">
              <label>Flash</label>
              <span id="flashSize">-</span>
            </div>
            <div class="info-item">
              <label>PSRAM</label>
              <span id="psramSize">-</span>
            </div>
            <div class="info-item">
              <label>MAC</label>
              <span id="macAddress">-</span>
            </div>
          </div>
        </div>

        <div class="form-group" id="productSelect" style="display: none;">
          <label>Select firmware:</label>
          <select id="productDropdown"></select>
        </div>
        
        <div id="firmwareInfo" style="background: var(--surface-elevated); padding: 0.75rem; border-radius: 0.5rem; margin-bottom: 1rem; display: none;">
          <span style="color: var(--text-muted); font-size: 0.8rem;">Selected: </span>
          <span id="selectedFirmware" style="color: var(--primary); font-size: 0.85rem;">-</span>
        </div>

        <button id="flashBtn" class="btn btn-success" onclick="flashFirmware()">
          Flash Firmware
        </button>
      </div>

      <!-- Step 3: WiFi Setup -->
      <div id="newStep3" style="display: none;">
        <h2 style="font-size: 1.1rem; margin-bottom: 0.5rem;">Step 3: Configure WiFi</h2>
        <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1rem;">
          Connecting to device and scanning for networks...
        </p>
        <button id="wifiSetupBtn" class="btn btn-primary" disabled>
          Scanning...
        </button>
      </div>

      <!-- Step 4: Complete -->
      <div id="newStep4" style="display: none;">
        <div style="text-align: center; padding: 2rem 0;">
          <div style="width: 48px; height: 48px; background: var(--success); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 1rem;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3">
              <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
          </div>
          <h2 style="font-size: 1.25rem; margin-bottom: 0.5rem;">Setup Complete!</h2>
          <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 1rem;">
            Your device is ready. Hostname: <strong id="finalHostname">-</strong>
          </p>
        </div>
        
        <!-- Browser Security Warning Guidance -->
        <div class="hint-box" style="text-align: left; margin-bottom: 1rem;">
          <i class="ti ti-alert-triangle" style="color: var(--warning);"></i>
          <div style="flex: 1;">
            <strong style="display: block; margin-bottom: 0.25rem;">Next: Accept Browser Security Warning</strong>
            <span style="font-size: 0.8rem;">
              When you visit your device, your browser will show a security warning. 
              This is expected — click <strong>"Advanced"</strong> then <strong>"Proceed"</strong> 
              to trust your device's self-signed certificate. You only need to do this once.
            </span>
          </div>
        </div>
        
        <a id="deviceLink" href="#" target="_blank" class="btn btn-primary" style="text-decoration: none;">
          <i class="ti ti-external-link"></i> Open Device Setup
        </a>
        <button class="btn btn-secondary" onclick="goHome()" style="margin-top: 0.5rem;">
          Done
        </button>
      </div>
    </div>

    <!-- View: Forgot Credentials -->
    <div id="viewForgot" class="view">
      <button class="btn-back" onclick="goBackToScenarios()">← Back</button>
      
      <h2 style="font-size: 1.1rem; margin-bottom: 0.5rem;">Recover Credentials</h2>
      <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1.5rem;">
        Reading device settings...
      </p>

      <div id="forgotCredentials" style="display: none;">
        <div class="credential-box">
          <label>Hostname</label>
          <div class="value-row">
            <div class="value" id="recoveredHostname">-</div>
            <button class="btn-copy" onclick="copyToClipboard('recoveredHostname')" title="Copy">
              <i class="ti ti-copy"></i>
            </button>
          </div>
        </div>
        <div class="credential-box">
          <label>Password</label>
          <div class="value-row">
            <div class="value" id="recoveredPassword">-</div>
            <button class="btn-copy" onclick="copyToClipboard('recoveredPassword')" title="Copy">
              <i class="ti ti-copy"></i>
            </button>
          </div>
        </div>
        <div class="credential-box">
          <label>WiFi Network</label>
          <div class="value-row">
            <div class="value" id="recoveredSSID">-</div>
            <button class="btn-copy" onclick="copyToClipboard('recoveredSSID')" title="Copy">
              <i class="ti ti-copy"></i>
            </button>
          </div>
        </div>
        <button class="btn btn-secondary" onclick="goHome()" style="margin-top: 1rem;">
          Done
        </button>
      </div>
    </div>

    <!-- View: Change WiFi -->
    <div id="viewWifi" class="view">
      <button class="btn-back" onclick="goBackToScenarios()">← Back</button>
      
      <h2 style="font-size: 1.1rem; margin-bottom: 0.5rem;">Change WiFi Network</h2>
      <p id="wifiChangeStatus" style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1.5rem;">
        Connecting to device to scan for networks...
      </p>
      <!-- Status shown in terminal log below -->
    </div>

    <!-- View: Re-provision -->
    <div id="viewRebless" class="view">
      <button class="btn-back" onclick="goBackToScenarios()">← Back</button>
      
      <h2 style="font-size: 1.1rem; margin-bottom: 0.5rem;">Re-provision Device</h2>
      <p style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1.5rem;">
        Generating new certificates and password. WiFi settings will be preserved.
      </p>

      <!-- Step 1: Processing (shown during provisioning) -->
      <div id="reblessStep1">
        <div id="reblessStatus" style="color: var(--primary);">Connecting...</div>
      </div>

      <!-- Step 2: Complete (shown after device reset) -->
      <div id="reblessStep2" style="display: none;">
        <div style="text-align: center; padding: 2rem 0;">
          <div style="width: 48px; height: 48px; background: var(--success); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 1rem;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3">
              <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
          </div>
          <h2 style="font-size: 1.25rem; margin-bottom: 0.5rem;">Re-provision Complete!</h2>
          <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 1rem;">
            Your device has new certificates. Hostname: <strong id="reblessFinalHostname">-</strong>
          </p>
        </div>
        
        <!-- Browser Security Warning Guidance -->
        <div class="hint-box" style="text-align: left; margin-bottom: 1rem;">
          <i class="ti ti-alert-triangle" style="color: var(--warning);"></i>
          <div style="flex: 1;">
            <strong style="display: block; margin-bottom: 0.25rem;">Next: Accept Browser Security Warning</strong>
            <span style="font-size: 0.8rem;">
              When you visit your device, your browser will show a security warning. 
              This is expected — click <strong>"Advanced"</strong> then <strong>"Proceed"</strong> 
              to trust your device's new certificate.
            </span>
          </div>
        </div>
        
        <a id="reblessDeviceLink" href="#" target="_blank" class="btn btn-primary" style="text-decoration: none;">
          <i class="ti ti-external-link"></i> Open Device Setup
        </a>
        <button class="btn btn-secondary" onclick="goHome()" style="margin-top: 0.5rem;">
          Done
        </button>
      </div>
    </div>

    <!-- Terminal (Collapsible) -->
    <div class="terminal-wrapper" id="terminalWrapper">
      <div class="terminal-header" onclick="toggleTerminal()">
        <span><i class="ti ti-terminal-2"></i> Status Log</span>
        <span class="terminal-toggle"><i class="ti ti-chevron-down"></i></span>
      </div>
      <div class="terminal-content" id="debugLog">
        <div>> Ready</div>
      </div>
    </div>

    <!-- Footer -->
    <div class="footer">
      <p>
        Requires Chrome, Edge, or Opera •
        <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Serial_API#browser_compatibility" target="_blank">Browser compatibility</a>
      </p>
      <p style="margin-top: 0.5rem;">
        <a href="https://github.com/jetpax/pyDirect" target="_blank">GitHub</a> •
        <a href="https://scriptostudio.com/docs" target="_blank">Documentation</a>
      </p>
    </div>
  </div>

  <!-- WiFi Network Selection Modal -->
  <div id="wifiModal" class="modal-overlay">
    <div class="modal">
      <h3><i class="ti ti-wifi"></i> Select WiFi Network</h3>
      <div id="wifiNetworkList"></div>
      <button id="wifiCancelBtn" class="btn btn-secondary" onclick="closeWifiModal()" style="margin-top: 1rem;">
        Cancel
      </button>
    </div>
  </div>

  <!-- Flash Complete Modal -->
  <div id="flashCompleteModal" class="modal-overlay">
    <div class="modal" style="text-align: center;">
      <div style="width: 48px; height: 48px; background: var(--success); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 1rem;">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
      </div>
      <h3 style="margin-bottom: 0.5rem;">Flash Complete</h3>
      <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 1.5rem;">
        pyDirect firmware installed successfully.<br>
        Ready for WiFi configuration.
      </p>
      <button id="proceedWifiSetupBtn" class="btn btn-primary">
        Configure WiFi
      </button>
      <button id="skipWifiSetupBtn" class="btn btn-secondary">
        Skip for now
      </button>
    </div>
  </div>

  <script type="module">
    import { ESPLoader } from './assets/libs/tasmota-esptool-v7-real.bundle.js';
    import forge from 'https://esm.sh/node-forge@1.3.1';

    // ========== VIEW NAVIGATION ==========
    
    function showView(viewId) {
      document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
      document.getElementById(viewId)?.classList.add('active');
    }
    
    // Expose to global scope for onclick handlers
    window.goHome = function() {
      showView('viewLanding');
      resetState();
      // Reset landing view to initial state (show connect, hide scenarios)
      document.getElementById('landingConnect').style.display = 'block';
      document.getElementById('landingScenarios').style.display = 'none';
      const btn = document.getElementById('landingConnectBtn');
      if (btn) {
        btn.innerHTML = '<i class="ti ti-usb"></i> Connect Device';
        btn.disabled = false;
      }
      document.getElementById('welcomeSubtitle').textContent = 'Connect your device to get started';
    };
    
    // Go back to scenario selection, re-entering bootloader if needed
    window.goBackToScenarios = async function() {
      addLog('Returning to scenario selection...');
      
      // If we have no port at all (e.g., after device reset), go back to connect screen
      if (!currentPort) {
        addLog('No connection - please reconnect');
        goHome();
        return;
      }
      
      // If we have a port but no loader, we need to re-enter bootloader
      if (currentPort && !currentLoader) {
        try {
          addLog('Re-entering bootloader mode...');
          
          // Close port if open (might be in REPL mode)
          try { await currentPort.close(); } catch(e) {}
          await new Promise(r => setTimeout(r, 100)); // Brief delay after close
          
          // Re-open at bootloader baud rate
          await currentPort.open({ baudRate: 115200 });
          await new Promise(r => setTimeout(r, 100)); // Brief delay after open
          
          // Create new ESPLoader and initialize (this triggers reset into download mode)
          const loader = new ESPLoader(currentPort, { log: console.log, debug: console.debug, error: console.error });
          await loader.initialize();
          
          // Run stub for better performance
          const stubLoader = await loader.runStub();
          currentLoader = stubLoader || loader;
          
          addLog('Bootloader reconnected');
        } catch (e) {
          console.error('[goBackToScenarios] Reconnect error:', e);
          addLog(`Reconnect failed: ${e.message}`)
          // Fall back to full reset - user will need to re-select port
          goHome();
          return;
        }
      }
      
      // Show scenario selection with scenarios visible
      clearLog();
      addLog('Device connected - select an action');
      showView('viewLanding');
      document.getElementById('landingConnect').style.display = 'none';
      document.getElementById('landingScenarios').style.display = 'block';
    };
    
    window.selectScenario = function(scenario) {
      currentScenario = scenario;
      addLog(`Selected: ${scenario}`);
      
      switch(scenario) {
        case 'new':
          // Already connected via bootloader, go directly to step 2 (firmware selection)
          showView('viewNewDevice');
          updateProgressSteps(2);
          showNewDeviceStep(2);
          // Update device info in step 2
          document.getElementById('detectedChip').textContent = detectedChipName;
          document.getElementById('detectedMac').textContent = detectedMacAddress;
          break;
        case 'forgot':
          showView('viewForgot');
          // Immediately transition from bootloader to REPL using existing port
          addLog('Transitioning to REPL mode...');
          readCredentials();
          break;
        case 'wifi':
          showView('viewWifi');
          // Immediately transition from bootloader to REPL using existing port
          addLog('Transitioning to REPL mode...');
          performWifiSetup();
          break;
        case 'rebless':
          showView('viewRebless');
          // Immediately transition from bootloader to REPL using existing port
          addLog('Transitioning to REPL mode...');
          startRebless();
          break;
      }
    };
    
    function updateProgressSteps(current) {
      for (let i = 1; i <= 4; i++) {
        const step = document.getElementById(`step${i}`);
        if (!step) continue;
        step.classList.remove('active', 'complete');
        if (i < current) step.classList.add('complete');
        if (i === current) step.classList.add('active');
      }
    }
    
    function showNewDeviceStep(stepNum) {
      for (let i = 1; i <= 4; i++) {
        const el = document.getElementById(`newStep${i}`);
        if (el) el.style.display = i === stepNum ? 'block' : 'none';
      }
      updateProgressSteps(stepNum);
    }
    
    // ========== TERMINAL ==========
    
    window.toggleTerminal = function() {
      document.getElementById('terminalWrapper')?.classList.toggle('collapsed');
    };
    
    function addLog(msg) {
      const log = document.getElementById('debugLog');
      if (!log) return;
      const line = document.createElement('div');
      line.textContent = `> ${msg}`;
      log.appendChild(line);
      log.scrollTop = log.scrollHeight;
      // Auto-expand terminal when logging
      document.getElementById('terminalWrapper')?.classList.remove('collapsed');
    }
    
    function clearLog() {
      const log = document.getElementById('debugLog');
      if (log) log.innerHTML = '<div>> Ready</div>';
    }
    
    // ========== MODAL HELPERS ==========
    
    window.closeWifiModal = function() {
      document.getElementById('wifiModal')?.classList.remove('active');
    };
    

    
    // ========== COPY TO CLIPBOARD ==========
    
    window.copyToClipboard = async function(elementId) {
      const el = document.getElementById(elementId);
      if (!el) return;
      
      const text = el.textContent;
      try {
        await navigator.clipboard.writeText(text);
        
        // Find the copy button and show feedback
        const btn = el.closest('.value-row')?.querySelector('.btn-copy i');
        if (btn) {
          btn.className = 'ti ti-check';
          setTimeout(() => { btn.className = 'ti ti-copy'; }, 1500);
        }
        addLog(`Copied: ${text}`);
      } catch (err) {
        addLog('Copy failed');
      }
    };
    
    // ========== UNIFIED CONNECTION AT LANDING ==========
    
    let isBlankDevice = true; // True if no pyDirect firmware detected
    
    window.connectAndDetect = async function() {
      const btn = document.getElementById('landingConnectBtn');
      
      // Clear previous logs
      clearLog();
      
      // Ensure any previous connection is fully closed
      try {
        if (currentLoader) {
          await currentLoader.disconnect();
          currentLoader = null;
        }
        if (currentPort) {
          await currentPort.close();
          currentPort = null;
        }
      } catch (e) {
        console.log('Cleanup previous connection:', e);
      }
      
      try {
        btn.innerHTML = '<i class="ti ti-loader"></i> Connecting...';
        btn.disabled = true;
        addLog('Requesting serial port...');
        
        // Request a new port
        currentPort = await navigator.serial.requestPort({});
        await currentPort.open({ baudRate: 115200 });
        addLog('Port opened');
        
        // ALWAYS start with bootloader detection (most reliable)
        addLog('Detecting hardware...');
        const result = await detectHardware(currentPort);
        detectedChipName = result.chipName;
        detectedMacAddress = result.macAddress;
        // Note: currentLoader is set as a side-effect inside detectHardware()
        
        addLog(`Detected: ${detectedChipName}`);
        addLog(`MAC: ${detectedMacAddress}`);
        
        // For now, treat all bootloader-connected devices as "blank" 
        // (they need firmware to have ScriptO Studio)
        // TODO: Read NVS partition to detect magic marker for existing installs
        isBlankDevice = true;
        
        // Update device info display
        document.getElementById('connectedChipName').textContent = detectedChipName;
        
        // Show scenarios
        document.getElementById('landingConnect').style.display = 'none';
        document.getElementById('landingScenarios').style.display = 'block';
        document.getElementById('welcomeSubtitle').textContent = 'Fast-path acceleration for Embedded Python';
        
        if (isBlankDevice) {
          document.getElementById('deviceStatus').textContent = 'Ready to Flash';
          // Note: User can still try other options - they'll work if device has firmware
          addLog('Device connected - select an action');
        } else {
          document.getElementById('deviceStatus').textContent = 'ScriptO Ready';
          document.getElementById('deviceStatus').style.background = 'var(--success)';
          addLog('ScriptO Studio detected - choose an action');
        }
        
      } catch (error) {
        console.error('Connection error:', error);
        addLog(`Error: ${error.message}`);
        btn.innerHTML = '<i class="ti ti-usb"></i> Connect Device';
        btn.disabled = false;
        
        try { if (currentPort) await currentPort.close(); } catch (e) {}
        currentPort = null;
        currentLoader = null;
      }
    };
    
    window.disconnectDevice = async function() {
      try {
        if (currentLoader) {
          await currentLoader.disconnect();
          currentLoader = null;
        }
        if (currentPort) {
          // Reset the device to normal boot mode before closing
          // DTR=false keeps GPIO0 high (normal boot, not download mode)
          // Pulse RTS to trigger hardware reset
          try {
            await currentPort.setSignals({ dataTerminalReady: false, requestToSend: false });
            await new Promise(resolve => setTimeout(resolve, 50));
            await currentPort.setSignals({ dataTerminalReady: false, requestToSend: true }); // Assert reset
            await new Promise(resolve => setTimeout(resolve, 100));
            await currentPort.setSignals({ dataTerminalReady: false, requestToSend: false }); // Release reset
            await new Promise(resolve => setTimeout(resolve, 100));
          } catch (e) {
            console.log('[disconnectDevice] Reset signals error:', e);
          }
          await currentPort.close();
          currentPort = null;
        }
      } catch (e) {}
      
      // Reset UI
      document.getElementById('landingConnect').style.display = 'block';
      document.getElementById('landingScenarios').style.display = 'none';
      document.getElementById('landingConnectBtn').innerHTML = '<i class="ti ti-usb"></i> Connect Device';
      document.getElementById('landingConnectBtn').disabled = false;
      document.getElementById('scenarioForgot').style.opacity = '';
      document.getElementById('scenarioWifi').style.opacity = '';
      document.getElementById('scenarioRebless').style.opacity = '';
      document.getElementById('deviceStatus').style.background = '';
      document.getElementById('welcomeSubtitle').textContent = 'Connect your device to get started';
      
      addLog('Disconnected');
    };

    // Generate self-signed certificate for device HTTPS
    function generateSelfSignedCert(hostname, validityYears = 10) {
      const keys = forge.pki.rsa.generateKeyPair(2048);
      const cert = forge.pki.createCertificate();
      
      cert.publicKey = keys.publicKey;
      cert.serialNumber = '01';
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + validityYears);
      
      const attrs = [{ name: 'commonName', value: hostname }];
      cert.setSubject(attrs);
      cert.setIssuer(attrs);
      
      // Add Subject Alternative Names for hostname.local and wildcard
      cert.setExtensions([
        { name: 'basicConstraints', cA: false },
        { name: 'keyUsage', digitalSignature: true, keyEncipherment: true },
        { name: 'extKeyUsage', serverAuth: true },
        {
          name: 'subjectAltName',
          altNames: [
            { type: 2, value: hostname },           // DNS
            { type: 2, value: `*.${hostname}` }     // Wildcard
          ]
        }
      ]);
      
      cert.sign(keys.privateKey, forge.md.sha256.create());
      
      return {
        certPem: forge.pki.certificateToPem(cert),
        keyPem: forge.pki.privateKeyToPem(keys.privateKey)
      };
    }

    // ========== DOM ELEMENTS ==========
    const chipNameEl = document.getElementById('chipName');
    const flashSizeEl = document.getElementById('flashSize');
    const psramSizeEl = document.getElementById('psramSize');
    const macAddressEl = document.getElementById('macAddress');
    const selectedFirmwareEl = document.getElementById('selectedFirmware');
    const productSelect = document.getElementById('productSelect');
    const productDropdown = document.getElementById('productDropdown');

    // Global state
    let currentPort = null;
    let currentLoader = null;
    let detectedChipName = null;
    let detectedMacAddress = null;
    let selectedProduct = null;
    let releaseInfo = null;  // Cache release info
    let currentScenario = null;  // Track active scenario
    
    function resetState() {
      if (currentPort) {
        try { currentPort.close(); } catch(e) {}
      }
      currentPort = null;
      currentLoader = null;
      detectedChipName = null;
      detectedMacAddress = null;
      selectedProduct = null;
      currentScenario = null;
      clearLog();
      // Reset new device flow to step 1
      showNewDeviceStep(1);
      // Reset re-provision flow to step 1
      const reblessStep1 = document.getElementById('reblessStep1');
      const reblessStep2 = document.getElementById('reblessStep2');
      const reblessStatus = document.getElementById('reblessStatus');
      if (reblessStep1) reblessStep1.style.display = 'block';
      if (reblessStep2) reblessStep2.style.display = 'none';
      if (reblessStatus) {
        reblessStatus.textContent = 'Connecting...';
        reblessStatus.style.color = 'var(--primary)';
      }
    }

    // GitHub repository for firmware releases
    const GITHUB_REPO = 'jetpax/pyDirect';
    const RELEASES_API = `https://api.github.com/repos/${GITHUB_REPO}/releases/latest`;
    
    // CORS proxy for GitHub release downloads (GitHub doesn't allow cross-origin downloads)
    // When served from GitHub Pages (same origin), we can try direct download first
    const CORS_PROXY = 'https://corsproxy.io/?';

    // Map chip targets to chip families (for matching detected chip to firmware)
    const CHIP_TARGETS = {
      'ESP32_S3': 'ESP32-S3',
      'ESP32_P4': 'ESP32-P4',
      'ESP32_S2': 'ESP32-S2',
      'ESP32_C3': 'ESP32-C3',
      'ESP32_C6': 'ESP32-C6',
      'ESP32': 'ESP32'
    };

    // Parse firmware assets from release to build product options
    async function loadFirmwareOptions() {
      try {
        console.log('Fetching release info from:', RELEASES_API);
        const resp = await fetch(RELEASES_API);
        if (!resp.ok) throw new Error(`Failed to fetch release: ${resp.status}`);
        
        releaseInfo = await resp.json();
        console.log('Latest release:', releaseInfo.tag_name);

        // Find merged firmware files only
        const firmwareAssets = releaseInfo.assets.filter(a => 
          a.name.startsWith('pyDirect-') && a.name.endsWith('-merged.bin')
        );

        // Parse into product options grouped by chip family
        const options = {};
        for (const asset of firmwareAssets) {
          // Parse: pyDirect-{product}-merged.bin
          const match = asset.name.match(/^pyDirect-(.+)-merged\.bin$/);
          if (!match) continue;
          
          const productId = match[1];  // e.g., "ESP32_S3", "ESP32_S3_16MB", "RetroVMS_Mini"
          
          // Determine chip family from product ID
          let chipFamily = null;
          for (const [target, family] of Object.entries(CHIP_TARGETS)) {
            if (productId.startsWith(target) || productId.includes(target)) {
              chipFamily = family;
              break;
            }
          }
          
          // For products like RetroVMS_Mini, we need to check which chip they target
          // If no chip family detected, default to ESP32-S3 (most common)
          if (!chipFamily) {
            // Could also check release notes or use a manifest, but for now assume S3
            chipFamily = 'ESP32-S3';
          }

          if (!options[chipFamily]) options[chipFamily] = [];
          
          // Generate human-readable name
          let name = productId.replace(/_/g, ' ').replace(/16MB/g, '16MB').replace(/8MB/g, '8MB');
          if (productId === 'ESP32_S3') name = 'Generic ESP32-S3 (8MB Flash)';
          else if (productId === 'ESP32_S3_16MB') name = 'Generic ESP32-S3 (16MB Flash)';
          else if (productId === 'ESP32_P4') name = 'ESP32-P4 (with C6 WiFi)';
          
          options[chipFamily].push({
            id: productId,
            name: name,
            asset: asset.name,
            // Prefer relative path (works on GitHub Pages, same origin)
            // Fall back to direct GitHub download URL if relative fails
            relativePath: `./firmware/${asset.name}`,
            downloadUrl: asset.browser_download_url,
            size: asset.size
          });
        }

        console.log('Discovered firmware options:', options);
        return options;
      } catch (error) {
        console.error('Failed to load firmware options:', error);
        return null;
      }
    }

    // Update firmware display when product selection changes
    productDropdown.addEventListener('change', () => {
      if (window.productOptions) {
        const chipFamily = detectedChipName?.includes('ESP32-S3') ? 'ESP32-S3' : 
                          detectedChipName?.includes('ESP32-P4') ? 'ESP32-P4' : null;
        if (chipFamily && window.productOptions[chipFamily]) {
          const product = window.productOptions[chipFamily].find(p => p.id === productDropdown.value);
          if (product) {
            selectedProduct = product;
            selectedFirmwareEl.textContent = `${product.name} (${(product.size / 1024 / 1024).toFixed(1)} MB)`;
          }
        }
      }
    });

    // Chip-specific eFuse base addresses (from tasmota-webserial-esptool v7.3.4)
    const EFUSE_BASES = {
      'ESP32-S3': 0x60007000,
      'ESP32-S2': 0x3f41A000,
      'ESP32-P4': 0x5012D000,
      'ESP32': 0x3ff5A000
    };

    // Helper function to read eFuse register
    async function readEfuseRegister(loader, address) {
      try {
        return await loader.readRegister(address);
      } catch (e) {
        console.warn(`Failed to read eFuse register at ${address.toString(16)}:`, e);
        return null;
      }
    }

    // Detect PSRAM for ESP32-S3
    async function detectS3Psram(loader) {
      const EFUSE_BASE = EFUSE_BASES['ESP32-S3'];
      const reg = await readEfuseRegister(loader, EFUSE_BASE + 0x044 + 4 * 4);
      
      if (reg === null) return 'Unknown';
      
      const psramCap = (reg >> 3) & 0x03;
      const psramVendor = (reg >> 7) & 0x03;
      
      const psramSizes = {
        0: null,
        1: '8MB',
        2: '2MB',
        3: '8MB or more'
      };
      
      const psramVendors = {
        1: 'AP_3v3',
        2: 'AP_1v8'
      };
      
      const size = psramSizes[psramCap];
      if (!size) return 'None';
      
      const vendor = psramVendors[psramVendor];
      return vendor ? `${size} (${vendor})` : size;
    }

    // Detect PSRAM for ESP32-S2
    async function detectS2Psram(loader) {
      const EFUSE_BASE = EFUSE_BASES['ESP32-S2'];
      const EFUSE_BLOCK1_ADDR = EFUSE_BASE + 0x44;
      const reg = await readEfuseRegister(loader, EFUSE_BLOCK1_ADDR + 4 * 3);
      
      if (reg === null) return 'Unknown';
      
      const psramCap = (reg >> 28) & 0x0f;
      
      const psramSizes = {
        0: null,
        1: '2MB'
      };
      
      const size = psramSizes[psramCap];
      return size || 'None';
    }

    // Detect PSRAM based on chip type
    async function detectPsram(loader, chipName) {
      if (chipName.includes('ESP32-S3')) {
        return await detectS3Psram(loader);
      } else if (chipName.includes('ESP32-S2')) {
        return await detectS2Psram(loader);
      } else {
        // For other chips, try feature detection
        try {
          if (loader.chip.getChipFeatures) {
            const features = await loader.chip.getChipFeatures(loader);
            console.log("Chip Features:", features);
            
            // Check for PSRAM in features
            const psramFeature = features.find(f => f.includes('PSRAM'));
            if (psramFeature) {
              return psramFeature.replace('Embedded ', '');
            }
          }
        } catch (e) {
          console.warn("Feature detection failed:", e);
        }
        return 'None';
      }
    }

    // Perform hardware detection
    async function detectHardware(port) {
      const logger = {
        log: (msg) => console.log(msg),
        debug: (msg) => console.debug(msg),
        error: (msg) => console.error(msg)
      };

      const loader = new ESPLoader(port, logger);

      // Connect and detect chip (ROM mode)
      await loader.initialize();
      const chipName = loader.chipName || 'Unknown';
      console.log("Connected to chip:", chipName);

      // MAC Address
      const macAddr = loader.macAddr();
      const macAddress = Array.isArray(macAddr) && macAddr.length >= 6
        ? macAddr.slice(0, 6).map(b => b.toString(16).padStart(2, '0')).join(':')
        : 'Unknown';
      
      // Run the stub loader for advanced detection
      let flashSizeMB = 'Unknown';
      let psramInfo = 'Unknown';

      try {
          console.log("Running stub...");
          const stubLoader = await loader.runStub();
          
          // Detect flash size using the stub
          await stubLoader.detectFlashSize();
          flashSizeMB = stubLoader.flashSize || 'Unknown';
          console.log("Flash size detected:", flashSizeMB);

          // Detect PSRAM using chip-specific eFuse reads
          psramInfo = await detectPsram(stubLoader, chipName);
          console.log("PSRAM detected:", psramInfo);
          
          // Keep the stub loader for flashing
          currentLoader = stubLoader;
          
      } catch (e) {
          console.warn("Stub/Feature detection failed:", e);
          flashSizeMB = 'Detection Failed';
          psramInfo = 'Detection Failed';
          currentLoader = loader;
      }

      // Update UI
      chipNameEl.textContent = chipName || 'Unknown';
      flashSizeEl.textContent = flashSizeMB;
      psramSizeEl.textContent = psramInfo;
      macAddressEl.textContent = macAddress;

      // Show device info card
      deviceInfo.classList.add('visible');

      // Determine chip family and populate product dropdown
      const chipFamily = chipName?.includes('ESP32-S3') ? 'ESP32-S3' : 
                        chipName?.includes('ESP32-P4') ? 'ESP32-P4' : null;
      
      if (chipFamily) {
        // Load firmware options dynamically from GitHub release
        selectedFirmwareEl.textContent = 'Loading available firmware...';
        const productOptions = await loadFirmwareOptions();
        window.productOptions = productOptions;  // Store for dropdown change handler
        
        if (productOptions && productOptions[chipFamily]) {
          const options = productOptions[chipFamily];
          
          // Populate dropdown
          productDropdown.innerHTML = options.map(opt => 
            `<option value="${opt.id}">${opt.name} (${(opt.size / 1024 / 1024).toFixed(1)} MB)</option>`
          ).join('');
          
          // Auto-select based on detected flash size
          let defaultProduct = options[0];
          if (chipFamily === 'ESP32-S3') {
            // Parse flash size (e.g., "16 MB" -> 16)
            const flashMB = parseInt(flashSizeMB);
            if (flashMB >= 16) {
              // Prefer 16MB variant for 16MB+ chips
              defaultProduct = options.find(o => o.id === 'ESP32_S3_16MB') || options[0];
            }
          }
          
          productDropdown.value = defaultProduct.id;
          selectedProduct = defaultProduct;
          selectedFirmwareEl.textContent = `${defaultProduct.name} (${(defaultProduct.size / 1024 / 1024).toFixed(1)} MB)`;
          
          // Show product selection
          productSelect.style.display = 'block';
        } else {
          selectedFirmwareEl.textContent = `No firmware available for ${chipFamily}`;
        }
      }
      
      firmwareInfo.classList.add('visible');

      return { chipName, flashSizeMB, psramInfo, macAddress };
    }

    // ========== CONNECT DEVICE (New Device Flow) ==========
    window.connectDevice = async function() {
      const btn = document.getElementById('connectBtn');
      try {
        btn.textContent = 'Connecting...';
        btn.disabled = true;
        addLog('Requesting serial port...');

        // Request serial port
        currentPort = await navigator.serial.requestPort({});
        await currentPort.open({ baudRate: 115200 });
        addLog('Port opened at 115200 baud');

        // Perform detection
        addLog('Detecting hardware...');
        const result = await detectHardware(currentPort);
        detectedChipName = result.chipName;
        detectedMacAddress = result.macAddress;
        addLog(`Detected: ${result.chipName}, Flash: ${result.flashSizeMB}`);

        // Move to step 2
        showNewDeviceStep(2);

      } catch (error) {
        console.error('Detection error:', error);
        addLog(`Error: ${error.message}`);
        btn.textContent = 'Connect to ESP32';
        btn.disabled = false;
        
        // Clean up on error
        if (currentPort) {
          try { await currentPort.close(); } catch (e) {}
          currentPort = null;
        }
        currentLoader = null;
      }
    };

    // REPL Communication Helpers
    async function sendCtrlC(port) {
      const writer = port.writable.getWriter();
      await writer.write(new Uint8Array([0x03])); // Ctrl+C
      writer.releaseLock();
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    // Shared helper: Transition from bootloader mode to REPL
    // Used by: performWifiSetup, readCredentials, startRebless
    // IMPORTANT: Watches for boot banner and immediately sends Ctrl+C before main.py can disable it
    async function transitionToREPL() {
      // Disconnect loader if we have one
      if (currentLoader) {
        await currentLoader.disconnect();
        currentLoader = null;
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      // Close and reopen at MicroPython baud rate
      await currentPort.close();
      await new Promise(resolve => setTimeout(resolve, 100));
      await currentPort.open({ baudRate: 115200 });
      
      // Reset the device to normal boot (not download mode)
      // DTR=false keeps GPIO0 high (normal boot mode)
      // Pulse RTS to trigger reset
      await currentPort.setSignals({ dataTerminalReady: false, requestToSend: false });
      await new Promise(resolve => setTimeout(resolve, 50));
      await currentPort.setSignals({ dataTerminalReady: false, requestToSend: true }); // Assert reset
      await new Promise(resolve => setTimeout(resolve, 100));
      await currentPort.setSignals({ dataTerminalReady: false, requestToSend: false }); // Release reset
      
      // Watch for the pyDirect banner - must send Ctrl+C BEFORE main.py disables it
      const bootReader = currentPort.readable.getReader();
      const bootDecoder = new TextDecoder();
      let bootOutput = '';
      const bootStart = Date.now();
      let bannerFound = false;
      
      while (Date.now() - bootStart < 8000) { // 8 second max wait
        const { value, done } = await bootReader.read();
        if (done) break;
        if (value) {
          bootOutput += bootDecoder.decode(value);
          if (bootOutput.includes('System booting...')) {
            bannerFound = true;
            bootReader.releaseLock();
            
            // IMMEDIATELY send Ctrl+C before main.py starts
            const writer = currentPort.writable.getWriter();
            await writer.write(new Uint8Array([0x03, 0x03, 0x03]));
            await new Promise(r => setTimeout(r, 30));
            await writer.write(new Uint8Array([0x03, 0x03]));
            writer.releaseLock();
            break;
          }
        }
      }
      
      // Release reader if no banner (timeout case)
      if (!bannerFound) {
        bootReader.releaseLock();
        const writer = currentPort.writable.getWriter();
        await writer.write(new Uint8Array([0x03, 0x03]));
        writer.releaseLock();
      }
      
      // Brief pause for interrupt to take effect
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Drain pending data from serial buffer
      try {
        const drainReader = currentPort.readable.getReader();
        const drainTimeout = setTimeout(() => drainReader.cancel(), 500);
        try {
          while (true) {
            const { value, done } = await drainReader.read();
            if (done) break;
          }
        } catch (e) { /* Expected - cancel() causes read to throw */ }
        clearTimeout(drainTimeout);
        drainReader.releaseLock();
      } catch (e) {
        console.log('[DRAIN] Error:', e);
      }
    }

    async function sendREPLCommand(port, pythonCode, timeoutMs = 15000, enterRawMode = true) {
      const writer = port.writable.getWriter();
      
      try {
        // Clean the Python code - remove common leading whitespace but preserve relative indentation
        const lines = pythonCode.split('\n').filter(line => line.trim().length > 0);
        const minIndent = Math.min(...lines.map(line => {
          const match = line.match(/^(\s*)/);
          return match ? match[1].length : 0;
        }));
        const cleanCode = lines.map(line => line.slice(minIndent)).join('\n');
        
        // Only enter raw REPL if requested (first command)
        if (enterRawMode) {
          await writer.write(new Uint8Array([0x01])); // Ctrl+A - enter raw REPL
          await new Promise(r => setTimeout(r, 100));
        }
        
        // Send code in chunks to avoid buffer issues with Web Serial
        const encoded = new TextEncoder().encode(cleanCode);
        const CHUNK_SIZE = 64;  // Small chunks to ensure delivery
        for (let i = 0; i < encoded.length; i += CHUNK_SIZE) {
          const chunk = encoded.slice(i, Math.min(i + CHUNK_SIZE, encoded.length));
          await writer.write(chunk);
          await new Promise(r => setTimeout(r, 10));  // Small delay for buffer flush
        }
        await new Promise(r => setTimeout(r, 50));
        await writer.write(new Uint8Array([0x04])); // Ctrl+D - execute
        writer.releaseLock();
        
        // Now read the response
        const reader = port.readable.getReader();
        let output = '';
        const decoder = new TextDecoder();
        const startTime = Date.now();
        
        // Read until we see the pattern: ...OK...output...>
        // We need to see "OK" (code accepted) followed eventually by ">" (execution done)
        while (Date.now() - startTime < timeoutMs) {
          const { value, done } = await reader.read();
          
          if (done) break;
          if (value) {
            output += decoder.decode(value);
            if (output.includes('OK') && output.endsWith('>')) {
              break;
            }
          }
        }


        
        // Stay in raw REPL mode - don't exit (no Ctrl+B)
        // This avoids the repeated "MicroPython..." banner
        
        reader.releaseLock();
        return output;
      } catch (e) {
        try { writer.releaseLock(); } catch {}
        throw e;
      }
    }

    // Upload certificates to device filesystem via REPL
    async function uploadCertsToDevice(port, certPem, keyPem, log) {
      log('Creating /certs directory...');
      
      // Create /certs directory (ignore error if exists)
      await sendREPLCommand(port, `
import os
try:
    os.mkdir('/certs')
except OSError:
    pass
print('DIR_OK')
`, 3000, false);

      log('Writing certificate...');
      
      // Write cert file using base64 to handle special characters
      const certB64 = btoa(certPem);
      await sendREPLCommand(port, `
import binascii
with open('/certs/servercert.pem', 'wb') as f:
    f.write(binascii.a2b_base64('${certB64}'))
print('CERT_OK')
`, 5000, false);

      log('Writing private key...');
      
      // Write key file
      const keyB64 = btoa(keyPem);
      await sendREPLCommand(port, `
with open('/certs/prvtkey.pem', 'wb') as f:
    f.write(binascii.a2b_base64('${keyB64}'))
print('KEY_OK')
`, 5000, false);

      log('Certificates installed!');
    }

    // Core WiFi setup function - transitions from bootloader to REPL and configures WiFi
    async function performWifiSetup() {
      clearLog();
      
      try {
        wifiSetupBtn.style.display = 'block';
        wifiSetupBtn.textContent = 'Connecting to REPL...';
        wifiSetupBtn.disabled = true;
        
        addLog('Connecting to REPL...');
        
        // Transition from bootloader to REPL (with banner detection)
        await transitionToREPL();
        
        addLog('Scanning for WiFi networks...');
        wifiSetupBtn.textContent = 'Scanning networks...';
        
        // Scan networks via REPL - output as JSON for easy parsing
        const scanOutput = await sendREPLCommand(currentPort, `
import network  # MicroPython built-in (has WLAN)
import json
wlan = network.WLAN(network.STA_IF)
wlan.active(True)
raw = wlan.scan()
# Deduplicate by SSID, keeping strongest signal
nets = {}
for ssid, bssid, channel, rssi, authmode, hidden in raw:
    s = ssid.decode()
    if s and (s not in nets or rssi > nets[s][0]):
        nets[s] = (rssi, authmode)
# Convert to sorted list (by rssi descending)
result = [{"ssid": k, "rssi": v[0], "sec": v[1] != 0} for k, v in nets.items()]
result.sort(key=lambda x: x["rssi"], reverse=True)
print("JSON:" + json.dumps(result))
`);
        

        
        // Extract JSON from output
        const jsonMatch = scanOutput.match(/JSON:(\[.*\])/);
        if (!jsonMatch) {
          throw new Error('Failed to parse network scan - no JSON found');
        }
        
        let networks;
        try {
          networks = JSON.parse(jsonMatch[1]);
        } catch (e) {
          throw new Error('Failed to parse network JSON: ' + e.message);
        }
        
        if (networks.length === 0) {
          throw new Error('No WiFi networks found');
        }
        
        addLog(`Found ${networks.length} networks`);
        
        // Network selection and connection loop (allows retry on failure)
        let connected = false;
        let deviceIP = null;
        let savedHostname = null;
        
        // Helper to show network selection modal
        function showNetworkModal(networks) {
          return new Promise((resolve, reject) => {
            const modal = document.getElementById('wifiModal');
            const list = document.getElementById('wifiNetworkList');
            const cancelBtn = document.getElementById('wifiCancelBtn');
            
            // Build network list HTML with Tabler icons
            list.innerHTML = networks.map((n, i) => {
              const bars = n.rssi >= -50 ? '▂▄▆█' : n.rssi >= -60 ? '▂▄▆_' : n.rssi >= -70 ? '▂▄__' : n.rssi >= -80 ? '▂___' : '▂___';
              const lockIcon = n.sec ? '<i class="ti ti-lock" style="margin-right: 0.25rem;"></i>' : '';
              return `<button class="wifi-item" data-index="${i}" style="
                width: 100%;
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0.75rem 1rem;
                margin-bottom: 0.5rem;
                background: #374151;
                color: white;
                border: 2px solid transparent;
                border-radius: 0.5rem;
                cursor: pointer;
                transition: all 0.2s;
              " onmouseover="this.style.borderColor='var(--primary)'" onmouseout="this.style.borderColor='transparent'">
                <span style="font-weight: 500;">${n.ssid}</span>
                <span style="font-family: monospace; opacity: 0.7;">${lockIcon}${bars}</span>
              </button>`;
            }).join('');
            
            // Show modal using classList
            modal.classList.add('active');
            
            // Handle network click
            const handleClick = (e) => {
              const btn = e.target.closest('.wifi-item');
              if (btn) {
                const index = parseInt(btn.dataset.index);
                cleanup();
                resolve(index);
              }
            };
            
            // Handle cancel
            const handleCancel = () => {
              cleanup();
              reject(new Error('Setup cancelled'));
            };
            
            const cleanup = () => {
              modal.classList.remove('active');
              list.removeEventListener('click', handleClick);
              cancelBtn.removeEventListener('click', handleCancel);
            };
            
            list.addEventListener('click', handleClick);
            cancelBtn.addEventListener('click', handleCancel);
          });
        }
        
        while (!connected) {
          // Show network selection modal
          const selectedIndex = await showNetworkModal(networks);
          
          const selectedNetwork = networks[selectedIndex];
          const password = prompt(`Enter password for "${selectedNetwork.ssid}":`);
          
          if (password === null) {
            // User cancelled password - let them reselect network
            continue;
          }
          
          addLog(`Connecting to "${selectedNetwork.ssid}"...`);
          wifiSetupBtn.textContent = 'Connecting to WiFi...';
          
          // Connect to WiFi via REPL (already in raw mode from scan)
          const connectOutput = await sendREPLCommand(currentPort, `
import time
try:
    wlan.disconnect()
except:
    pass
time.sleep(0.3)
wlan.connect('${selectedNetwork.ssid}', '${password}')
for i in range(20):
    if wlan.isconnected():
        ip = wlan.ifconfig()[0]
        print(f"CONNECTED:{ip}")
        break
    time.sleep(0.5)
else:
    print("FAILED:timeout")
`, 15000, false);  // Already in raw mode
          

          
          // Parse connection result
          const connMatch = connectOutput.match(/CONNECTED:(\d+\.\d+\.\d+\.\d+)/);
          if (connMatch) {
            deviceIP = connMatch[1];
            connected = true;
            addLog(`Connected! IP: ${deviceIP}`);
            
            // Save WiFi credentials and hostname to settings
            addLog(`Saving settings...`);
            
            // Compute hostname from ESPLoader MAC (base MAC - consistent across interfaces)
            const macSuffix = detectedMacAddress 
              ? detectedMacAddress.replace(/:/g, '').slice(-4).toLowerCase()
              : 'xxxx';
            const hostname = `pydirect-${macSuffix}`;
            
            await sendREPLCommand(currentPort, `
from lib.sys import settings
settings.set("wifi.ssid", "${selectedNetwork.ssid}")
settings.set("wifi.password", "${password}")
settings.set("server.https_enabled", True)
settings.set("device.hostname", "${hostname}")
settings.save()
print("SETTINGS_OK")
`, 5000, false);
            addLog(`Settings saved (hostname: ${hostname})`);
            
            // Store for cert generation
            savedHostname = hostname;
          } else {
            addLog('Connection failed');
            const retry = confirm('WiFi connection failed. Wrong password?\n\nClick OK to try again, or Cancel to abort.');
            if (!retry) {
              throw new Error('Connection cancelled');
            }
            wifiSetupBtn.textContent = 'Retrying...';
          }
        }
        
        // Generate and install HTTPS certificate
        wifiSetupBtn.textContent = 'Generating certificate...';
        addLog('Generating HTTPS certificate...');
        
        // Use hostname saved to settings (from ESPLoader base MAC)
        const certHostname = savedHostname + '.local';
        addLog(`Hostname: ${certHostname}`);
        
        // Generate self-signed certificate
        const { certPem, keyPem } = generateSelfSignedCert(certHostname);
        addLog(`Certificate generated (${certPem.length} bytes)`);
        
        // Upload to device
        wifiSetupBtn.textContent = 'Installing certificate...';
        await uploadCertsToDevice(currentPort, certPem, keyPem, addLog);
        
        // === Set setup mode flag before reset ===
        wifiSetupBtn.textContent = 'Configuring setup mode...';
        addLog('Setting setup mode flag...');
        await sendREPLCommand(currentPort, `
from lib.sys import settings
settings.set("setup_mode", True)
settings.save()
print("SETUP_MODE_SET")
`, 5000, false);
        
        // Hard reset to apply settings and enter setup mode
        wifiSetupBtn.textContent = 'Restarting device...';
        addLog('Resetting device...');
        await sendREPLCommand(currentPort, 'import machine; machine.reset()', 1000, false);
        
        // Close port
        await currentPort.close();
        currentPort = null;
        
        // Show Step 4 with device link and browser warning guidance
        const setupUrl = `https://${certHostname}/setup`;
        addLog(`Device ready at ${setupUrl}`);
        
        // Update Step 4 UI
        document.getElementById('finalHostname').textContent = certHostname;
        document.getElementById('deviceLink').href = setupUrl;
        
        // Show Step 4
        updateProgressSteps(4);
        showNewDeviceStep(4);
        
        addLog('Setup complete! Click "Open Device Setup" to continue.');


      } catch (error) {
        // Handle user cancellation gracefully (don't show error)
        if (error.message?.includes('cancelled')) {
          console.log('WiFi setup cancelled by user');
          return;
        }
        
        console.error('WiFi setup error:', error);
        addLog(`Error: ${error.message}`);
        wifiSetupBtn.textContent = 'Retry WiFi Setup';
        wifiSetupBtn.disabled = false;
        
        // Clean up on error
        try {
          if (currentPort) await currentPort.close();
        } catch (e) {}
        currentPort = null;
        currentLoader = null;
      }
    }
    
    // Wire up the REPL WiFi setup button
    wifiSetupBtn.addEventListener('click', async () => {
      if (!currentPort && !currentLoader) {
        // No active connection - need to reconnect
        await performWifiSetup();
      } else {
        // Have a connection (either from bootloader or already in MicroPython)
        await performWifiSetup();
      }
    });
    
    // Wire up Flash Complete modal buttons
    document.getElementById('proceedWifiSetupBtn').addEventListener('click', async () => {
      // Hide the modal
      document.getElementById('flashCompleteModal').style.display = 'none';
      // Start WiFi setup - we have the port reference, just need to switch baud rate
      await performWifiSetup();
    });
    
    document.getElementById('skipWifiSetupBtn').addEventListener('click', async () => {
      // Hide the modal
      document.getElementById('flashCompleteModal').style.display = 'none';
      // Reset UI elements
      connectBtn.textContent = 'Connect & Install pyDirect';
      connectBtn.disabled = false;
      connectBtn.style.background = 'var(--primary)';
      connectBtn.style.display = 'block';
      flashBtn.style.display = 'none';
      wifiSetupBtn.style.display = 'none';
      // Clean up serial connection
      try {
        if (currentPort) await currentPort.close();
      } catch (e) {}
      currentPort = null;
      currentLoader = null;
    });

    // ========== FLASH FIRMWARE ==========
    window.flashFirmware = async function() {
      const btn = document.getElementById('flashBtn');
      if (!currentPort || !currentLoader) {
        addLog('Error: No device connected');
        return;
      }

      if (!selectedProduct) {
        addLog('Error: No firmware selected');
        return;
      }
      
      // Confirmation dialog
      const confirmed = confirm(
        `⚠️ FLASH FIRMWARE ⚠️\n\n` +
        `This will ERASE all data on the device and install:\n` +
        `${selectedProduct.name}\n\n` +
        `Any existing scripts, settings, and certificates will be PERMANENTLY DELETED.\n\n` +
        `Are you sure you want to continue?`
      );
      
      if (!confirmed) {
        addLog('Flash cancelled by user');
        return;
      }

      try {
        btn.textContent = 'Downloading...';
        btn.disabled = true;
        addLog(`Downloading ${selectedProduct.name}...`);

        // Download the firmware
        let firmwareResp;
        try {
          firmwareResp = await fetch(selectedProduct.relativePath);
          if (!firmwareResp.ok) throw new Error('Local not found');
        } catch (e) {
          addLog('Using CORS proxy...');
          const proxyUrl = CORS_PROXY + encodeURIComponent(selectedProduct.downloadUrl);
          firmwareResp = await fetch(proxyUrl);
        }
        
        if (!firmwareResp.ok) throw new Error(`Download failed: ${firmwareResp.status}`);
        const data = new Uint8Array(await firmwareResp.arrayBuffer());
        addLog(`Downloaded ${(data.length / 1024 / 1024).toFixed(1)} MB`);
        
        // Sync and flash
        btn.textContent = 'Syncing...';
        try {
          await currentLoader.sync();
        } catch (e) {
          await currentLoader.initialize();
        }
        
        btn.textContent = 'Flashing...';
        addLog('Flashing firmware...');
        let progressPercent = 0;
        
        try {
          await currentLoader.flashData(
            data.buffer,
            (bytesWritten, totalBytes) => {
              progressPercent = Math.floor((bytesWritten / totalBytes) * 100);
              btn.textContent = `Flashing: ${progressPercent}%`;
              if (progressPercent % 10 === 0) addLog(`Progress: ${progressPercent}%`);
            },
            0, true
          );
        } catch (flashError) {
          const errorMsg = flashError?.message || String(flashError);
          if (errorMsg.includes('Timed out') && progressPercent >= 95) {
            addLog('Flash complete (device rebooted)');
          } else {
            throw flashError;
          }
        }

        addLog('✓ Flash complete!');
        btn.textContent = '✓ Complete';
        
        try { await currentLoader.disconnect(); } catch (e) {}
        currentLoader = null;
        
        // Show modal
        document.getElementById('flashCompleteModal')?.classList.add('active');

      } catch (error) {
        console.error('Flash error:', error);
        addLog(`Flash failed: ${error.message}`);
        btn.textContent = 'Flash Failed';
        btn.disabled = false;
        
        try { if (currentPort) await currentPort.close(); } catch (e) {}
        currentPort = null;
        currentLoader = null;
      }
    };

    // ========== CREDENTIAL RECOVERY (uses pre-connected port) ==========
    async function readCredentials() {
      const credsDiv = document.getElementById('forgotCredentials');
      
      try {
        addLog('Reading credentials from device...');
        
        // Transition from bootloader to REPL
        await transitionToREPL();
        
        // Read settings
        const output = await sendREPLCommand(currentPort, `
import json
from lib.sys import settings
hostname = settings.get("device.hostname", "unknown")
password = settings.get("server.webrepl_password", "not set")
ssid = settings.get("wifi.ssid", "not set")
print("CREDS:" + json.dumps({"h": hostname, "p": password, "s": ssid}))
`);
        
        const match = output.match(/CREDS:(\{.*\})/);
        if (match) {
          const creds = JSON.parse(match[1]);
          document.getElementById('recoveredHostname').textContent = creds.h + '.local';
          document.getElementById('recoveredPassword').textContent = creds.p;
          document.getElementById('recoveredSSID').textContent = creds.s;
          addLog(`Found: ${creds.h}.local`);
          if (credsDiv) credsDiv.style.display = 'block';
        } else {
          throw new Error('Could not read settings - device may need firmware');
        }
        
      } catch (error) {
        addLog(`Error: ${error.message}`);
      }
    }

    // ========== RE-PROVISION (uses pre-connected port) ==========
    async function startRebless() {
      try {
        addLog('Starting re-provisioning...');
        document.getElementById('reblessStatus').textContent = 'Connecting to REPL...';
        
        // Transition from bootloader to REPL
        await transitionToREPL();
        
        // Read current hostname
        document.getElementById('reblessStatus').textContent = 'Reading device settings...';
        const output = await sendREPLCommand(currentPort, `
from lib.sys import settings
print("HOST:" + settings.get("device.hostname", "pydirect-xxxx"))
`);
        
        const match = output.match(/HOST:(.+)/);
        const hostname = match ? match[1].trim() : 'pydirect-new';
        
        addLog(`Generating new certificate for ${hostname}.local...`);
        document.getElementById('reblessStatus').textContent = 'Generating certificate...';
        const certHostname = hostname + '.local';
        const { certPem, keyPem } = generateSelfSignedCert(certHostname);
        
        addLog('Installing new certificate...');
        document.getElementById('reblessStatus').textContent = 'Installing certificate...';
        await uploadCertsToDevice(currentPort, certPem, keyPem, addLog);
        
        // Enable setup mode so device shows password entry page
        addLog('Enabling setup mode...');
        document.getElementById('reblessStatus').textContent = 'Configuring setup mode...';
        await sendREPLCommand(currentPort, `
from lib.sys import settings
settings.set("setup_mode", True)
settings.save()
print("SETUP_MODE_SET")
`, 5000, false);
        
        addLog('Restarting device...');
        document.getElementById('reblessStatus').textContent = 'Restarting device...';
        await sendREPLCommand(currentPort, 'import machine; machine.reset()', 1000, false);
        
        // Keep port reference but null loader - device is rebooting
        // goBackToScenarios will close/reopen port to re-enter bootloader
        currentLoader = null;
        
        addLog(`✓ Re-provisioning complete!`);
        addLog(`Device ready at: https://${certHostname}`);
        
        // Show completion UI with device link
        const setupUrl = `https://${certHostname}/setup`;
        document.getElementById('reblessFinalHostname').textContent = certHostname;
        document.getElementById('reblessDeviceLink').href = setupUrl;
        document.getElementById('reblessStep1').style.display = 'none';
        document.getElementById('reblessStep2').style.display = 'block';
        
        addLog('Click "Open Device Setup" to set your password.');
        
        // Collapse terminal for cleaner completion screen
        document.getElementById('terminalWrapper')?.classList.add('collapsed');
        
      } catch (error) {
        addLog(`Error: ${error.message}`);
        document.getElementById('reblessStatus').textContent = `Error: ${error.message}`;
        document.getElementById('reblessStatus').style.color = 'var(--error)';
      }
    }
    
    window.connectForRebless = async function() {
      try {
        addLog('Connecting for re-provisioning...');
        
        currentPort = await navigator.serial.requestPort({});
        await currentPort.open({ baudRate: 115200 });
        addLog('Connected');
        
        await sendCtrlC(currentPort);
        await new Promise(r => setTimeout(r, 300));
        
        // Read current hostname
        const output = await sendREPLCommand(currentPort, `
from lib.sys import settings
print("HOST:" + settings.get("device.hostname", "pydirect-xxxx"))
`);
        
        const match = output.match(/HOST:(.+)/);
        const hostname = match ? match[1].trim() : 'pydirect-new';
        
        addLog(`Generating new certificate for ${hostname}.local...`);
        const certHostname = hostname + '.local';
        const { certPem, keyPem } = generateSelfSignedCert(certHostname);
        
        addLog('Installing new certificate...');
        await uploadCertsToDevice(currentPort, certPem, keyPem, addLog);
        
        // Set new password via prompt
        const newPassword = prompt('Enter new WebREPL password:');
        if (newPassword) {
          await sendREPLCommand(currentPort, `
from lib.sys import settings
settings.set("server.webrepl_password", "${newPassword}")
settings.set("setup_mode", False)
settings.save()
print("SAVED")
`, 5000, false);
          addLog('New password saved');
        }
        
        addLog('Restarting device...');
        await sendREPLCommand(currentPort, 'import machine; machine.reset()', 1000, false);
        
        await currentPort.close();
        currentPort = null;
        
        addLog(`✓ Re-provisioning complete!`);
        addLog(`Connect at: https://${certHostname}`);
        
      } catch (error) {
        addLog(`Error: ${error.message}`);
        try { if (currentPort) await currentPort.close(); } catch (e) {}
        currentPort = null;
      }
    };

    // ========== MODAL HANDLERS ==========
    document.getElementById('proceedWifiSetupBtn')?.addEventListener('click', async () => {
      document.getElementById('flashCompleteModal')?.classList.remove('active');
      showNewDeviceStep(3);
      await performWifiSetup();
    });
    
    document.getElementById('skipWifiSetupBtn')?.addEventListener('click', () => {
      document.getElementById('flashCompleteModal')?.classList.remove('active');
      goHome();
    });
  </script>
</body>
</html>
